<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/PhysicalConfigView.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/PhysicalConfigView.tsx" />
              <option name="originalContent" value="// --- Physical Configuration View ---&#10;import {Block, CreateEventFormData, Row, SessionSeatingMapRequest} from &quot;@/lib/validators/event&quot;;&#10;import {useFormContext} from &quot;react-hook-form&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {LayoutData, SeatingLayoutTemplateResponse} from &quot;@/types/seatingLayout&quot;;&#10;import {&#10;    createSeatingLayoutTemplate,&#10;    deleteSeatingLayoutTemplate,&#10;    getSeatingLayoutTemplatesByOrg,&#10;    updateSeatingLayoutTemplate&#10;} from &quot;@/lib/actions/seatingLayoutTemplateActions&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {LayoutEditor} from &quot;@/app/manage/organization/[organization_id]/seating/_components/LayoutEditor&quot;;&#10;import {TierAssignmentEditor} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierAssignmentEditor&quot;;&#10;import {ProgressSteps} from &quot;./physical-config/ProgressSteps&quot;;&#10;import {NavigationButtons} from &quot;./physical-config/NavigationButtons&quot;;&#10;import {LayoutSelector} from &quot;./physical-config/LayoutSelector&quot;;&#10;import {DeleteConfirmationDialog} from &quot;./physical-config/DeleteConfirmationDialog&quot;;&#10;import {getRowLabel} from &quot;@/app/manage/organization/[organization_id]/seating/create/_lib/getRowLabel&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;&#10;type Step = {&#10;    id: string;&#10;    label: string;&#10;}&#10;&#10;export function PhysicalConfigView({onSave, initialConfig}: {&#10;    onSave: (layout: SessionSeatingMapRequest) =&gt; void;&#10;    initialConfig?: SessionSeatingMapRequest;&#10;}) {&#10;    const {watch} = useFormContext&lt;CreateEventFormData&gt;();&#10;    const organizationId = watch('organizationId');&#10;    const tiers = watch('tiers');&#10;    const [templates, setTemplates] = useState&lt;SeatingLayoutTemplateResponse[]&gt;([]);&#10;    const [mode, setMode] = useState&lt;'select' | 'create' | 'assign'&gt;('select');&#10;    const [selectedLayout, setSelectedLayout] = useState&lt;LayoutData | null&gt;(null);&#10;    const [selectedTemplateId, setSelectedTemplateId] = useState&lt;string | null&gt;(null);&#10;    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);&#10;    const [layoutToDelete, setLayoutToDelete] = useState&lt;{ id: string, name: string } | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [currentAssignedLayout, setCurrentAssignedLayout] = useState&lt;SessionSeatingMapRequest | null&gt;(null);&#10;&#10;    // Progress steps configuration&#10;    const steps: Step[] = [&#10;        {id: 'select', label: 'Select Layout'},&#10;        {id: 'create', label: 'Edit Layout'},&#10;        {id: 'assign', label: 'Assign Tiers'},&#10;    ];&#10;&#10;    // If initialConfig is provided, we should start at the assign step&#10;    useEffect(() =&gt; {&#10;        if (initialConfig &amp;&amp; initialConfig.name !== null) {&#10;            setCurrentAssignedLayout(initialConfig);&#10;            setMode('assign');&#10;        }&#10;    }, [initialConfig]);&#10;&#10;    const loadTemplates = useCallback(async () =&gt; {&#10;        setIsLoading(true);&#10;        try {&#10;            const res = await getSeatingLayoutTemplatesByOrg(organizationId, 0, 100);&#10;            setTemplates(res.content);&#10;        } catch (error) {&#10;            toast.error(&quot;Failed to load layout templates&quot;);&#10;            console.error(error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, [organizationId]);&#10;&#10;    // Fetch templates when component loads or organization changes&#10;    useEffect(() =&gt; {&#10;        if (organizationId) {&#10;            loadTemplates().then();&#10;        }&#10;    }, [loadTemplates, organizationId]);&#10;&#10;    // Transform layout for tier assignment when selectedLayout changes&#10;    useEffect(() =&gt; {&#10;        if (!selectedLayout || mode !== 'assign') return;&#10;&#10;        const transformedBlocks = selectedLayout.layout.blocks.map((block) =&gt; {&#10;            const newBlock: Block = {&#10;                ...block,&#10;                rows: [],&#10;                seats: [],&#10;            };&#10;&#10;            if (block.type === 'seated_grid' &amp;&amp; block.rows &amp;&amp; block.columns) {&#10;                const startRowIndex = block.startRowLabel ? block.startRowLabel.charCodeAt(0) - 'A'.charCodeAt(0) : 0;&#10;                const startCol = block.startColumnLabel || 1;&#10;                const numRows = block.rows;&#10;                const numColumns = block.columns;&#10;&#10;                newBlock.rows = Array.from({length: numRows}, (_, rowIndex) =&gt; {&#10;                    const newRow: Row = {&#10;                        id: `temp_row_${block.id}_${rowIndex}`,&#10;                        label: `${getRowLabel(startRowIndex + rowIndex)}`,&#10;                        seats: Array.from({length: numColumns}, (_, colIndex) =&gt; ({&#10;                            id: `temp_seat_${block.id}_${rowIndex}_${colIndex}`,&#10;                            label: `${startCol + colIndex}${getRowLabel(startRowIndex + rowIndex)}`,&#10;                            status: 'AVAILABLE',&#10;                        })),&#10;                    };&#10;                    return newRow;&#10;                });&#10;            } else if (block.type === 'standing_capacity' &amp;&amp; block.capacity) {&#10;                const capacity = block.capacity;&#10;                newBlock.seats = Array.from({length: capacity}, (_, i) =&gt; ({&#10;                    id: `temp_seat_${block.id}_${i}`,&#10;                    label: `Slot ${i + 1}`,&#10;                    status: 'AVAILABLE',&#10;                }));&#10;            }&#10;            return newBlock;&#10;        });&#10;&#10;        setCurrentAssignedLayout({&#10;            name: selectedLayout.name,&#10;            layout: {&#10;                blocks: transformedBlocks,&#10;            },&#10;        });&#10;    }, [selectedLayout, mode]);&#10;&#10;    // Check if we need to auto-navigate to step 1 when going to step 2 without a layout&#10;    useEffect(() =&gt; {&#10;        if (mode === 'create' &amp;&amp; !selectedLayout &amp;&amp; !initialConfig) {&#10;            toast.error(&quot;Please select a layout first&quot;);&#10;            setMode('select');&#10;        }&#10;    }, [mode, selectedLayout, initialConfig]);&#10;&#10;    // Handle step navigation&#10;    const handleStepClick = (stepId: string) =&gt; {&#10;        // If trying to go to create step but no layout is selected, redirect to select&#10;        if (stepId === 'create' &amp;&amp; !selectedLayout) {&#10;            toast.error(&quot;Please select a layout first&quot;);&#10;            setMode('select');&#10;            return;&#10;        }&#10;&#10;        // If trying to go to assign step but no layout is prepared, redirect to select&#10;        if (stepId === 'assign' &amp;&amp; !currentAssignedLayout &amp;&amp; !selectedLayout) {&#10;            toast.error(&quot;Please select and configure a layout first&quot;);&#10;            setMode('select');&#10;            return;&#10;        }&#10;&#10;        setMode(stepId as 'select' | 'create' | 'assign');&#10;    };&#10;&#10;    // Handle layout selection&#10;    const handleLayoutSelect = (template: SeatingLayoutTemplateResponse) =&gt; {&#10;        setSelectedLayout(template.layoutData);&#10;        setSelectedTemplateId(template.id);&#10;    };&#10;&#10;    // Handle create from scratch&#10;    const handleCreateFromScratch = () =&gt; {&#10;        setSelectedLayout(null);&#10;        setSelectedTemplateId(null);&#10;        setMode('create');&#10;    };&#10;&#10;    // Handle delete confirmation - open dialog&#10;    const handleDeleteConfirm = (id: string, name: string) =&gt; {&#10;        setLayoutToDelete({id, name});&#10;        setIsDeleteDialogOpen(true);&#10;    };&#10;&#10;    // Handle actual deletion&#10;    const handleDeleteLayout = async () =&gt; {&#10;        if (!layoutToDelete) return;&#10;&#10;        try {&#10;            await deleteSeatingLayoutTemplate(layoutToDelete.id);&#10;            toast.success(`Layout &quot;${layoutToDelete.name}&quot; deleted successfully`);&#10;&#10;            // Refresh the templates list&#10;            await loadTemplates();&#10;&#10;            // If deleted template was selected, clear selection&#10;            if (selectedTemplateId === layoutToDelete.id) {&#10;                setSelectedLayout(null);&#10;                setSelectedTemplateId(null);&#10;            }&#10;        } catch (error) {&#10;            toast.error(&quot;Failed to delete layout template&quot;);&#10;            console.error(error);&#10;        } finally {&#10;            setIsDeleteDialogOpen(false);&#10;            setLayoutToDelete(null);&#10;        }&#10;    };&#10;&#10;    // Handle tier assignments updates from the editor&#10;    const handleTierAssignmentUpdate = (layoutWithTiers: SessionSeatingMapRequest) =&gt; {&#10;        setCurrentAssignedLayout(layoutWithTiers);&#10;    };&#10;&#10;    const handleTierAssignmentSave = () =&gt; {&#10;        if (!currentAssignedLayout) {&#10;            toast.error(&quot;No layout data available&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check if all seats and standing blocks have tier assignments&#10;        let hasUnassignedElements = false;&#10;&#10;        for (const block of currentAssignedLayout.layout.blocks) {&#10;            // Check seated blocks (rows with seats)&#10;            if (block.type === 'seated_grid' &amp;&amp; block.rows) {&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        // Seat must either have a tierId or be marked as RESERVED&#10;                        if (!seat.tierId &amp;&amp; seat.status !== 'RESERVED') {&#10;                            hasUnassignedElements = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (hasUnassignedElements) break;&#10;                }&#10;            }&#10;&#10;            // Check standing capacity blocks&#10;            if (block.type === 'standing_capacity' &amp;&amp; block.seats) {&#10;                // For standing blocks, check if at least one seat has a tier assignment&#10;                const hasAnyAssignedSeat = block.seats.some(seat =&gt; seat.tierId);&#10;                if (!hasAnyAssignedSeat &amp;&amp; block.seats.length &gt; 0) {&#10;                    hasUnassignedElements = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if (hasUnassignedElements) break;&#10;        }&#10;&#10;        if (hasUnassignedElements) {&#10;            toast.error(&quot;Please assign all seats to a tier or mark them as reserved. Standing areas must also have tier assignments.&quot;);&#10;            return;&#10;        }&#10;&#10;        // All elements are properly assigned, proceed with save&#10;        onSave(currentAssignedLayout);&#10;    };&#10;&#10;    const handleSave = async (layoutData: LayoutData) =&gt; {&#10;        const request = {&#10;            name: layoutData.name,&#10;            organizationId,&#10;            layoutData,&#10;        };&#10;&#10;        try {&#10;            // If we're editing an existing template, update it instead of creating a new one&#10;            if (selectedTemplateId) {&#10;                const data = await updateSeatingLayoutTemplate(selectedTemplateId, request);&#10;                toast.success(`Layout &quot;${data.name}&quot; updated successfully!`);&#10;&#10;                // Proceed to assign mode with updated layout data&#10;                setSelectedLayout(data.layoutData);&#10;                setMode(&quot;assign&quot;);&#10;&#10;                // Refresh the templates list to show the updated template&#10;                await loadTemplates();&#10;            } else {&#10;                // Creating a new template from scratch&#10;                const data = await createSeatingLayoutTemplate(request);&#10;                toast.success(`Layout &quot;${data.name}&quot; saved successfully!`);&#10;&#10;                // Proceed to assign mode with the new layout&#10;                setSelectedLayout(data.layoutData);&#10;                setSelectedTemplateId(data.id);&#10;                setMode(&quot;assign&quot;);&#10;&#10;                // Refresh the templates list to include the new template&#10;                await loadTemplates();&#10;            }&#10;        } catch (err) {&#10;            if (err instanceof Error) {&#10;                toast.error(err.message || 'Failed to save layout');&#10;            } else {&#10;                toast.error('An unexpected error occurred while saving the layout');&#10;            }&#10;            console.error(err);&#10;        }&#10;    };&#10;&#10;    // Navigation between steps&#10;    const goToPrevStep = () =&gt; {&#10;        if (mode === 'create') {&#10;            setMode('select');&#10;        } else if (mode === 'assign') {&#10;            setMode('create');&#10;&#10;            // Check if we have a layout to edit&#10;            if (!selectedLayout) {&#10;                toast.error(&quot;No layout available to edit&quot;);&#10;                setMode('select');&#10;            }&#10;        }&#10;    };&#10;&#10;    const goToNextStep = () =&gt; {&#10;        if (mode === 'select') {&#10;            if (!selectedLayout) {&#10;                toast.error(&quot;Please select a layout first&quot;);&#10;                return;&#10;            }&#10;            setMode('create');&#10;        } else if (mode === 'create') {&#10;            setMode('assign');&#10;        }&#10;    };&#10;&#10;    // Render different steps based on current mode&#10;    const renderCurrentStep = () =&gt; {&#10;        switch (mode) {&#10;            case 'create':&#10;                return (&#10;                    &lt;div className={&quot;h-[70vh] ring-1 ring-primary rounded-lg overflow-hidden&quot;}&gt;&#10;                        &lt;LayoutEditor&#10;                            onSave={handleSave}&#10;                            initialData={selectedLayout ?? undefined}&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                );&#10;            case 'assign':&#10;                // If we have initialConfig or currentAssignedLayout, show the TierAssignmentEditor&#10;                const layoutToEdit = currentAssignedLayout || initialConfig;&#10;&#10;                return layoutToEdit ? (&#10;                    &lt;TierAssignmentEditor&#10;                        layoutData={layoutToEdit}&#10;                        onChange={handleTierAssignmentUpdate}&#10;                        tiers={tiers}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className=&quot;p-4 text-center&quot;&gt;&#10;                        &lt;p&gt;No layout data available.&lt;/p&gt;&#10;                        &lt;Button&#10;                            variant=&quot;outline&quot;&#10;                            onClick={() =&gt; setMode('select')}&#10;                            className=&quot;mt-4&quot;&#10;                        &gt;&#10;                            Go to layout selection&#10;                        &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                );&#10;            case 'select':&#10;            default:&#10;                return (&#10;                    &lt;LayoutSelector&#10;                        templates={templates}&#10;                        selectedTemplateId={selectedTemplateId}&#10;                        isLoading={isLoading}&#10;                        onLayoutSelect={handleLayoutSelect}&#10;                        onCreateFromScratch={handleCreateFromScratch}&#10;                        onDeleteLayout={handleDeleteConfirm}&#10;                    /&gt;&#10;                );&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            &lt;ProgressSteps&#10;                steps={steps}&#10;                currentMode={mode}&#10;                onStepClick={handleStepClick}&#10;            /&gt;&#10;&#10;            {renderCurrentStep()}&#10;&#10;            &lt;NavigationButtons&#10;                currentMode={mode}&#10;                canProgress={!!selectedLayout}&#10;                onPrevious={goToPrevStep}&#10;                onNext={goToNextStep}&#10;                onFinish={handleTierAssignmentSave}&#10;            /&gt;&#10;&#10;            &lt;DeleteConfirmationDialog&#10;                isOpen={isDeleteDialogOpen}&#10;                onOpenChange={setIsDeleteDialogOpen}&#10;                layoutName={layoutToDelete?.name}&#10;                onConfirmDelete={handleDeleteLayout}&#10;            /&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="// --- Physical Configuration View ---&#10;import {Block, CreateEventFormData, Row, SessionSeatingMapRequest} from &quot;@/lib/validators/event&quot;;&#10;import {useFormContext} from &quot;react-hook-form&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {LayoutData, SeatingLayoutTemplateResponse} from &quot;@/types/seatingLayout&quot;;&#10;import {&#10;    createSeatingLayoutTemplate,&#10;    deleteSeatingLayoutTemplate,&#10;    getSeatingLayoutTemplatesByOrg,&#10;    updateSeatingLayoutTemplate&#10;} from &quot;@/lib/actions/seatingLayoutTemplateActions&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {LayoutEditor} from &quot;@/app/manage/organization/[organization_id]/seating/_components/LayoutEditor&quot;;&#10;import {TierAssignmentEditor} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierAssignmentEditor&quot;;&#10;import {ProgressSteps} from &quot;./physical-config/ProgressSteps&quot;;&#10;import {NavigationButtons} from &quot;./physical-config/NavigationButtons&quot;;&#10;import {LayoutSelector} from &quot;./physical-config/LayoutSelector&quot;;&#10;import {DeleteConfirmationDialog} from &quot;./physical-config/DeleteConfirmationDialog&quot;;&#10;import {getRowLabel} from &quot;@/app/manage/organization/[organization_id]/seating/create/_lib/getRowLabel&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;&#10;type Step = {&#10;    id: string;&#10;    label: string;&#10;}&#10;&#10;export function PhysicalConfigView({onSave, initialConfig}: {&#10;    onSave: (layout: SessionSeatingMapRequest) =&gt; void;&#10;    initialConfig?: SessionSeatingMapRequest;&#10;}) {&#10;    const {watch} = useFormContext&lt;CreateEventFormData&gt;();&#10;    const organizationId = watch('organizationId');&#10;    const tiers = watch('tiers');&#10;    const [templates, setTemplates] = useState&lt;SeatingLayoutTemplateResponse[]&gt;([]);&#10;    const [mode, setMode] = useState&lt;'select' | 'create' | 'assign'&gt;('select');&#10;    const [selectedLayout, setSelectedLayout] = useState&lt;LayoutData | null&gt;(null);&#10;    const [selectedTemplateId, setSelectedTemplateId] = useState&lt;string | null&gt;(null);&#10;    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);&#10;    const [layoutToDelete, setLayoutToDelete] = useState&lt;{ id: string, name: string } | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [currentAssignedLayout, setCurrentAssignedLayout] = useState&lt;SessionSeatingMapRequest | null&gt;(null);&#10;&#10;    // Progress steps configuration&#10;    const steps: Step[] = [&#10;        {id: 'select', label: 'Select Layout'},&#10;        {id: 'create', label: 'Edit Layout'},&#10;        {id: 'assign', label: 'Assign Tiers'},&#10;    ];&#10;&#10;    // If initialConfig is provided, we should start at the assign step&#10;    useEffect(() =&gt; {&#10;        if (initialConfig &amp;&amp; initialConfig.name !== null) {&#10;            setCurrentAssignedLayout(initialConfig);&#10;            setMode('assign');&#10;        }&#10;    }, [initialConfig]);&#10;&#10;    const loadTemplates = useCallback(async () =&gt; {&#10;        setIsLoading(true);&#10;        try {&#10;            const res = await getSeatingLayoutTemplatesByOrg(organizationId, 0, 100);&#10;            setTemplates(res.content);&#10;        } catch (error) {&#10;            toast.error(&quot;Failed to load layout templates&quot;);&#10;            console.error(error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, [organizationId]);&#10;&#10;    // Fetch templates when component loads or organization changes&#10;    useEffect(() =&gt; {&#10;        if (organizationId) {&#10;            loadTemplates().then();&#10;        }&#10;    }, [loadTemplates, organizationId]);&#10;&#10;    // Transform layout for tier assignment when selectedLayout changes&#10;    useEffect(() =&gt; {&#10;        if (!selectedLayout || mode !== 'assign') return;&#10;&#10;        const transformedBlocks = selectedLayout.layout.blocks.map((block) =&gt; {&#10;            const newBlock: Block = {&#10;                ...block,&#10;                rows: [],&#10;                seats: [],&#10;            };&#10;&#10;            if (block.type === 'seated_grid' &amp;&amp; block.rows &amp;&amp; block.columns) {&#10;                const startRowIndex = block.startRowLabel ? block.startRowLabel.charCodeAt(0) - 'A'.charCodeAt(0) : 0;&#10;                const startCol = block.startColumnLabel || 1;&#10;                const numRows = block.rows;&#10;                const numColumns = block.columns;&#10;&#10;                newBlock.rows = Array.from({length: numRows}, (_, rowIndex) =&gt; {&#10;                    const newRow: Row = {&#10;                        id: `temp_row_${block.id}_${rowIndex}`,&#10;                        label: `${getRowLabel(startRowIndex + rowIndex)}`,&#10;                        seats: Array.from({length: numColumns}, (_, colIndex) =&gt; ({&#10;                            id: `temp_seat_${block.id}_${rowIndex}_${colIndex}`,&#10;                            label: `${startCol + colIndex}${getRowLabel(startRowIndex + rowIndex)}`,&#10;                            status: 'AVAILABLE',&#10;                        })),&#10;                    };&#10;                    return newRow;&#10;                });&#10;            } else if (block.type === 'standing_capacity' &amp;&amp; block.capacity) {&#10;                const capacity = block.capacity;&#10;                newBlock.seats = Array.from({length: capacity}, (_, i) =&gt; ({&#10;                    id: `temp_seat_${block.id}_${i}`,&#10;                    label: `Slot ${i + 1}`,&#10;                    status: 'AVAILABLE',&#10;                }));&#10;            }&#10;            return newBlock;&#10;        });&#10;&#10;        setCurrentAssignedLayout({&#10;            name: selectedLayout.name,&#10;            layout: {&#10;                blocks: transformedBlocks,&#10;            },&#10;        });&#10;    }, [selectedLayout, mode]);&#10;&#10;    // Check if we need to auto-navigate to step 1 when going to step 2 without a layout&#10;    useEffect(() =&gt; {&#10;        if (mode === 'create' &amp;&amp; !selectedLayout &amp;&amp; !initialConfig) {&#10;            toast.error(&quot;Please select a layout first&quot;);&#10;            setMode('select');&#10;        }&#10;    }, [mode, selectedLayout, initialConfig]);&#10;&#10;    // Handle step navigation&#10;    const handleStepClick = (stepId: string) =&gt; {&#10;        // If trying to go to create step but no layout is selected, redirect to select&#10;        if (stepId === 'create' &amp;&amp; !selectedLayout) {&#10;            toast.error(&quot;Please select a layout first&quot;);&#10;            setMode('select');&#10;            return;&#10;        }&#10;&#10;        // If trying to go to assign step but no layout is prepared, redirect to select&#10;        if (stepId === 'assign' &amp;&amp; !currentAssignedLayout &amp;&amp; !selectedLayout) {&#10;            toast.error(&quot;Please select and configure a layout first&quot;);&#10;            setMode('select');&#10;            return;&#10;        }&#10;&#10;        setMode(stepId as 'select' | 'create' | 'assign');&#10;    };&#10;&#10;    // Handle layout selection&#10;    const handleLayoutSelect = (template: SeatingLayoutTemplateResponse) =&gt; {&#10;        setSelectedLayout(template.layoutData);&#10;        setSelectedTemplateId(template.id);&#10;    };&#10;&#10;    // Handle create from scratch&#10;    const handleCreateFromScratch = () =&gt; {&#10;        setSelectedLayout(null);&#10;        setSelectedTemplateId(null);&#10;        setMode('create');&#10;    };&#10;&#10;    // Handle delete confirmation - open dialog&#10;    const handleDeleteConfirm = (id: string, name: string) =&gt; {&#10;        setLayoutToDelete({id, name});&#10;        setIsDeleteDialogOpen(true);&#10;    };&#10;&#10;    // Handle actual deletion&#10;    const handleDeleteLayout = async () =&gt; {&#10;        if (!layoutToDelete) return;&#10;&#10;        try {&#10;            await deleteSeatingLayoutTemplate(layoutToDelete.id);&#10;            toast.success(`Layout &quot;${layoutToDelete.name}&quot; deleted successfully`);&#10;&#10;            // Refresh the templates list&#10;            await loadTemplates();&#10;&#10;            // If deleted template was selected, clear selection&#10;            if (selectedTemplateId === layoutToDelete.id) {&#10;                setSelectedLayout(null);&#10;                setSelectedTemplateId(null);&#10;            }&#10;        } catch (error) {&#10;            toast.error(&quot;Failed to delete layout template&quot;);&#10;            console.error(error);&#10;        } finally {&#10;            setIsDeleteDialogOpen(false);&#10;            setLayoutToDelete(null);&#10;        }&#10;    };&#10;&#10;    // Handle tier assignments updates from the editor&#10;    const handleTierAssignmentUpdate = (layoutWithTiers: SessionSeatingMapRequest) =&gt; {&#10;        setCurrentAssignedLayout(layoutWithTiers);&#10;    };&#10;&#10;    const handleTierAssignmentSave = () =&gt; {&#10;        if (!currentAssignedLayout) {&#10;            toast.error(&quot;No layout data available&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check if all seats and standing blocks have tier assignments&#10;        let hasUnassignedElements = false;&#10;&#10;        for (const block of currentAssignedLayout.layout.blocks) {&#10;            // Check seated blocks (rows with seats)&#10;            if (block.type === 'seated_grid' &amp;&amp; block.rows) {&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        // Seat must either have a tierId or be marked as RESERVED&#10;                        if (!seat.tierId &amp;&amp; seat.status !== 'RESERVED') {&#10;                            hasUnassignedElements = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (hasUnassignedElements) break;&#10;                }&#10;            }&#10;&#10;            // Check standing capacity blocks&#10;            if (block.type === 'standing_capacity' &amp;&amp; block.seats) {&#10;                // For standing blocks, check if at least one seat has a tier assignment&#10;                const hasAnyAssignedSeat = block.seats.some(seat =&gt; seat.tierId);&#10;                if (!hasAnyAssignedSeat &amp;&amp; block.seats.length &gt; 0) {&#10;                    hasUnassignedElements = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if (hasUnassignedElements) break;&#10;        }&#10;&#10;        if (hasUnassignedElements) {&#10;            toast.error(&quot;Please assign all seats to a tier or mark them as reserved. Standing areas must also have tier assignments.&quot;);&#10;            return;&#10;        }&#10;&#10;        // All elements are properly assigned, proceed with save&#10;        onSave(currentAssignedLayout);&#10;    };&#10;&#10;    const handleSave = async (layoutData: LayoutData) =&gt; {&#10;        const request = {&#10;            name: layoutData.name,&#10;            organizationId,&#10;            layoutData,&#10;        };&#10;&#10;        try {&#10;            // If we're editing an existing template, update it instead of creating a new one&#10;            if (selectedTemplateId) {&#10;                const data = await updateSeatingLayoutTemplate(selectedTemplateId, request);&#10;                toast.success(`Layout &quot;${data.name}&quot; updated successfully!`);&#10;                &#10;                // Only set layout data and change mode on success&#10;                setSelectedLayout(data.layoutData);&#10;                setMode(&quot;assign&quot;);&#10;                &#10;                // Refresh the templates list to show the updated template&#10;                await loadTemplates();&#10;            } else {&#10;                // Creating a new template from scratch&#10;                const data = await createSeatingLayoutTemplate(request);&#10;                toast.success(`Layout &quot;${data.name}&quot; saved successfully!`);&#10;                &#10;                // Only set layout data and change mode on success&#10;                setSelectedLayout(data.layoutData);&#10;                setSelectedTemplateId(data.id);&#10;                setMode(&quot;assign&quot;);&#10;                &#10;                // Refresh the templates list to include the new template&#10;                await loadTemplates();&#10;            }&#10;        } catch (err) {&#10;            if (err instanceof Error) {&#10;                toast.error(err.message || 'Failed to save layout');&#10;            } else {&#10;                toast.error('An unexpected error occurred while saving the layout');&#10;            }&#10;            console.error(err);&#10;        }&#10;    };&#10;&#10;    // Navigation between steps&#10;    const goToPrevStep = () =&gt; {&#10;        if (mode === 'create') {&#10;            setMode('select');&#10;        } else if (mode === 'assign') {&#10;            setMode('create');&#10;&#10;            // Check if we have a layout to edit&#10;            if (!selectedLayout) {&#10;                toast.error(&quot;No layout available to edit&quot;);&#10;                setMode('select');&#10;            }&#10;        }&#10;    };&#10;&#10;    const goToNextStep = () =&gt; {&#10;        if (mode === 'select') {&#10;            if (!selectedLayout) {&#10;                toast.error(&quot;Please select a layout first&quot;);&#10;                return;&#10;            }&#10;            setMode('create');&#10;        } else if (mode === 'create') {&#10;            setMode('assign');&#10;        }&#10;    };&#10;&#10;    // Render different steps based on current mode&#10;    const renderCurrentStep = () =&gt; {&#10;        switch (mode) {&#10;            case 'create':&#10;                return (&#10;                    &lt;div className={&quot;h-[70vh] ring-1 ring-primary rounded-lg overflow-hidden&quot;}&gt;&#10;                        &lt;LayoutEditor&#10;                            onSave={handleSave}&#10;                            initialData={selectedLayout ?? undefined}&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                );&#10;            case 'assign':&#10;                // If we have initialConfig or currentAssignedLayout, show the TierAssignmentEditor&#10;                const layoutToEdit = currentAssignedLayout || initialConfig;&#10;&#10;                return layoutToEdit ? (&#10;                    &lt;TierAssignmentEditor&#10;                        layoutData={layoutToEdit}&#10;                        onChange={handleTierAssignmentUpdate}&#10;                        tiers={tiers}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className=&quot;p-4 text-center&quot;&gt;&#10;                        &lt;p&gt;No layout data available.&lt;/p&gt;&#10;                        &lt;Button&#10;                            variant=&quot;outline&quot;&#10;                            onClick={() =&gt; setMode('select')}&#10;                            className=&quot;mt-4&quot;&#10;                        &gt;&#10;                            Go to layout selection&#10;                        &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                );&#10;            case 'select':&#10;            default:&#10;                return (&#10;                    &lt;LayoutSelector&#10;                        templates={templates}&#10;                        selectedTemplateId={selectedTemplateId}&#10;                        isLoading={isLoading}&#10;                        onLayoutSelect={handleLayoutSelect}&#10;                        onCreateFromScratch={handleCreateFromScratch}&#10;                        onDeleteLayout={handleDeleteConfirm}&#10;                    /&gt;&#10;                );&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            &lt;ProgressSteps&#10;                steps={steps}&#10;                currentMode={mode}&#10;                onStepClick={handleStepClick}&#10;            /&gt;&#10;&#10;            {renderCurrentStep()}&#10;&#10;            &lt;NavigationButtons&#10;                currentMode={mode}&#10;                canProgress={!!selectedLayout}&#10;                onPrevious={goToPrevStep}&#10;                onNext={goToNextStep}&#10;                onFinish={handleTierAssignmentSave}&#10;            /&gt;&#10;&#10;            &lt;DeleteConfirmationDialog&#10;                isOpen={isDeleteDialogOpen}&#10;                onOpenChange={setIsDeleteDialogOpen}&#10;                layoutName={layoutToDelete?.name}&#10;                onConfirmDelete={handleDeleteLayout}&#10;            /&gt;&#10;        &lt;/&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SeratingStep.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SeratingStep.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect} from 'react';&#10;import {useFieldArray, useFormContext} from 'react-hook-form';&#10;import {CreateEventFormData} from '@/lib/validators/event';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {&#10;    SessionListItemSeating&#10;} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionListItemSeating&quot;;&#10;import {OnlineConfigView} from &quot;@/app/manage/organization/[organization_id]/event/_components/OnlineConfigView&quot;;&#10;import {PhysicalConfigView} from &quot;@/app/manage/organization/[organization_id]/event/_components/PhysicalConfigView&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Checkbox} from &quot;@/components/ui/checkbox&quot;;&#10;import {Label} from &quot;@/components/ui/label&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {ArrowLeft} from &quot;lucide-react&quot;;&#10;&#10;interface SeatingStepProps {&#10;    onConfigModeChange?: (isInConfigMode: boolean) =&gt; void;&#10;}&#10;&#10;// --- Main Seating Step Component ---&#10;export function SeatingStep({ onConfigModeChange }: SeatingStepProps) {&#10;    const { control, formState: { errors }, watch, getValues, setValue } = useFormContext&lt;CreateEventFormData&gt;();&#10;    const [configuringIndex, setConfiguringIndex] = useState&lt;number | null&gt;(null);&#10;    const [applyToAll, setApplyToAll] = useState(false);&#10;&#10;    const { fields } = useFieldArray({&#10;        control,&#10;        name: &quot;sessions&quot;,&#10;    });&#10;&#10;    // Get the session being configured&#10;    const currentSession = configuringIndex !== null ? watch(`sessions.${configuringIndex}`) : null;&#10;&#10;    // Notify parent component when configuration mode changes&#10;    useEffect(() =&gt; {&#10;        if (onConfigModeChange) {&#10;            onConfigModeChange(configuringIndex !== null);&#10;        }&#10;    }, [configuringIndex, onConfigModeChange]);&#10;&#10;    const handleSave = (layoutData: any) =&gt; {&#10;        if (configuringIndex === null) return;&#10;&#10;        setValue(`sessions.${configuringIndex}.layoutData`, layoutData);&#10;&#10;        if (applyToAll) {&#10;            const allSessions = getValues('sessions');&#10;            allSessions.forEach((s, i) =&gt; {&#10;                // Apply only to sessions of the same type (online/physical)&#10;                if (s.isOnline === currentSession?.isOnline) {&#10;                    setValue(`sessions.${i}.layoutData`, layoutData);&#10;                }&#10;            });&#10;            toast.success(`Seating applied to all ${currentSession?.isOnline ? 'online' : 'physical'} sessions.`);&#10;        } else {&#10;            toast.success(`Seating configured for Session ${configuringIndex + 1}.`);&#10;        }&#10;&#10;        setConfiguringIndex(null);&#10;    };&#10;&#10;    // If we're configuring a session, show the full-page configuration view&#10;    if (configuringIndex !== null &amp;&amp; currentSession) {&#10;        return (&#10;            &lt;div className=&quot;space-y-4&quot;&gt;&#10;                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                    &lt;Button&#10;                        variant=&quot;ghost&quot;&#10;                        onClick={() =&gt; setConfiguringIndex(null)}&#10;                        className=&quot;flex items-center gap-1&quot;&#10;                    &gt;&#10;                        &lt;ArrowLeft className=&quot;h-4 w-4&quot; /&gt;&#10;                        Back to Sessions&#10;                    &lt;/Button&gt;&#10;                    &lt;h2 className=&quot;text-xl font-semibold&quot;&gt;&#10;                        Configure Seating for Session {configuringIndex + 1}&#10;                    &lt;/h2&gt;&#10;                    &lt;div&gt;&lt;/div&gt; {/* Empty div for flexbox spacing */}&#10;                &lt;/div&gt;&#10;&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;&#10;                            {currentSession.isOnline&#10;                                ? &quot;Online Capacity Configuration&quot;&#10;                                : &quot;Physical Seating Configuration&quot;}&#10;                        &lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;&#10;                            {currentSession.isOnline&#10;                                ? &quot;Set the capacity and ticket tier for your online event.&quot;&#10;                                : &quot;Choose a layout template or create a new one, then assign your tiers.&quot;}&#10;                        &lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent&gt;&#10;                        {currentSession.isOnline ? (&#10;                            &lt;OnlineConfigView onSave={handleSave} /&gt;&#10;                        ) : (&#10;                            &lt;PhysicalConfigView onSave={handleSave} /&gt;&#10;                        )}&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;&#10;                &lt;div className=&quot;flex items-center justify-between border-t pt-4 mt-8&quot;&gt;&#10;                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                        &lt;Checkbox&#10;                            id=&quot;apply-to-all-seating&quot;&#10;                            checked={applyToAll}&#10;                            onCheckedChange={(checked) =&gt; setApplyToAll(checked === true)}&#10;                        /&gt;&#10;                        &lt;Label htmlFor=&quot;apply-to-all-seating&quot;&gt;&#10;                            Apply to all {currentSession.isOnline ? 'online' : 'physical'} sessions&#10;                        &lt;/Label&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        );&#10;    }&#10;&#10;    // Otherwise show the session list&#10;    return (&#10;        &lt;Card&gt;&#10;            &lt;CardHeader&gt;&#10;                &lt;CardTitle&gt;Seating &amp; Tier Assignment&lt;/CardTitle&gt;&#10;                &lt;CardDescription&gt;&#10;                    Configure the seating layout and assign ticket tiers for each session.&#10;                &lt;/CardDescription&gt;&#10;            &lt;/CardHeader&gt;&#10;            &lt;CardContent className=&quot;space-y-4&quot;&gt;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;SessionListItemSeating&#10;                        key={field.id}&#10;                        field={field}&#10;                        index={index}&#10;                        onConfigure={() =&gt; setConfiguringIndex(index)}&#10;                    /&gt;&#10;                ))}&#10;&#10;                {errors.sessions?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.sessions.root.message}&lt;/p&gt;&#10;                )}&#10;            &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect} from 'react';&#10;import {useFieldArray, useFormContext} from 'react-hook-form';&#10;import {CreateEventFormData} from '@/lib/validators/event';&#10;import {SessionListItemSeating} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionListItemSeating&quot;;&#10;import {OnlineConfigView} from &quot;@/app/manage/organization/[organization_id]/event/_components/OnlineConfigView&quot;;&#10;import {PhysicalConfigView} from &quot;@/app/manage/organization/[organization_id]/event/_components/PhysicalConfigView&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Checkbox} from &quot;@/components/ui/checkbox&quot;;&#10;import {Label} from &quot;@/components/ui/label&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {ArrowLeft} from &quot;lucide-react&quot;;&#10;&#10;interface SeatingStepProps {&#10;    onConfigModeChange?: (isInConfigMode: boolean) =&gt; void;&#10;}&#10;&#10;// --- Main Seating Step Component ---&#10;export function SeatingStep({ onConfigModeChange }: SeatingStepProps) {&#10;    const { control, formState: { errors }, watch, getValues, setValue } = useFormContext&lt;CreateEventFormData&gt;();&#10;    const [configuringIndex, setConfiguringIndex] = useState&lt;number | null&gt;(null);&#10;    const [applyToAll, setApplyToAll] = useState(false);&#10;&#10;    const { fields } = useFieldArray({&#10;        control,&#10;        name: &quot;sessions&quot;,&#10;    });&#10;&#10;    // Get the session being configured&#10;    const currentSession = configuringIndex !== null ? watch(`sessions.${configuringIndex}`) : null;&#10;&#10;    // Notify parent component when configuration mode changes&#10;    useEffect(() =&gt; {&#10;        if (onConfigModeChange) {&#10;            onConfigModeChange(configuringIndex !== null);&#10;        }&#10;    }, [configuringIndex, onConfigModeChange]);&#10;&#10;    const handleSave = (layoutData: any) =&gt; {&#10;        if (configuringIndex === null) return;&#10;&#10;        setValue(`sessions.${configuringIndex}.layoutData`, layoutData);&#10;&#10;        if (applyToAll) {&#10;            const allSessions = getValues('sessions');&#10;            allSessions.forEach((s, i) =&gt; {&#10;                // Apply only to sessions of the same type (online/physical)&#10;                if (s.isOnline === currentSession?.isOnline) {&#10;                    setValue(`sessions.${i}.layoutData`, layoutData);&#10;                }&#10;            });&#10;            toast.success(`Seating applied to all ${currentSession?.isOnline ? 'online' : 'physical'} sessions.`);&#10;        } else {&#10;            toast.success(`Seating configured for Session ${configuringIndex + 1}.`);&#10;        }&#10;&#10;        setConfiguringIndex(null);&#10;    };&#10;&#10;    // If we're configuring a session, show the full-page configuration view&#10;    if (configuringIndex !== null &amp;&amp; currentSession) {&#10;        return (&#10;            &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                    &lt;Button&#10;                        variant=&quot;ghost&quot;&#10;                        onClick={() =&gt; setConfiguringIndex(null)}&#10;                        className=&quot;flex items-center gap-1&quot;&#10;                    &gt;&#10;                        &lt;ArrowLeft className=&quot;h-4 w-4&quot; /&gt;&#10;                        Back to Sessions&#10;                    &lt;/Button&gt;&#10;                    &lt;h2 className=&quot;text-xl font-semibold&quot;&gt;&#10;                        Configure Seating for Session {configuringIndex + 1}&#10;                    &lt;/h2&gt;&#10;                    &lt;div&gt;&lt;/div&gt; {/* Empty div for flexbox spacing */}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;space-y-2&quot;&gt;&#10;                    &lt;h3 className=&quot;text-lg font-medium&quot;&gt;&#10;                        {currentSession.isOnline&#10;                            ? &quot;Online Capacity Configuration&quot;&#10;                            : &quot;Physical Seating Configuration&quot;}&#10;                    &lt;/h3&gt;&#10;                    &lt;p className=&quot;text-muted-foreground text-sm&quot;&gt;&#10;                        {currentSession.isOnline&#10;                            ? &quot;Set the capacity and ticket tier for your online event.&quot;&#10;                            : &quot;Choose a layout template or create a new one, then assign your tiers.&quot;}&#10;                    &lt;/p&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;div className=&quot;border rounded-md p-6 bg-card&quot;&gt;&#10;                    {currentSession.isOnline ? (&#10;                        &lt;OnlineConfigView onSave={handleSave} /&gt;&#10;                    ) : (&#10;                        &lt;PhysicalConfigView onSave={handleSave} /&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;flex items-center border-t pt-4 mt-8&quot;&gt;&#10;                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                        &lt;Checkbox&#10;                            id=&quot;apply-to-all-seating&quot;&#10;                            checked={applyToAll}&#10;                            onCheckedChange={(checked) =&gt; setApplyToAll(checked === true)}&#10;                        /&gt;&#10;                        &lt;Label htmlFor=&quot;apply-to-all-seating&quot;&gt;&#10;                            Apply to all {currentSession.isOnline ? 'online' : 'physical'} sessions&#10;                        &lt;/Label&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        );&#10;    }&#10;&#10;    // Otherwise show the session list&#10;    return (&#10;        &lt;div className=&quot;space-y-6&quot;&gt;&#10;            &lt;div&gt;&#10;                &lt;h2 className=&quot;text-xl font-semibold mb-1&quot;&gt;Seating &amp; Tier Assignment&lt;/h2&gt;&#10;                &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;&#10;                    Configure the seating layout and assign ticket tiers for each session.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &#10;            &lt;div className=&quot;space-y-4&quot;&gt;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;SessionListItemSeating&#10;                        key={field.id}&#10;                        field={field}&#10;                        index={index}&#10;                        onConfigure={() =&gt; setConfiguringIndex(index)}&#10;                    /&gt;&#10;                ))}&#10;&#10;                {errors.sessions?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.sessions.root.message}&lt;/p&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/TierAssignmentEditor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/TierAssignmentEditor.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState} from 'react';&#10;import {Block, Tier} from '@/lib/validators/event';&#10;import {SessionSeatingMapRequest, Row, Seat} from '@/lib/validators/event';&#10;&#10;import {TierPalette} from './TierPalette';&#10;import {InteractiveDraggableBlock, InteractiveResizableBlock} from './InteractiveBlocks';&#10;import {toast} from 'sonner';&#10;&#10;interface TierAssignmentEditorProps {&#10;    layoutData: SessionSeatingMapRequest; // Now receiving the already-prepared layout data&#10;    tiers: Tier[];&#10;    onChange: (layout: SessionSeatingMapRequest) =&gt; void;&#10;}&#10;&#10;export function TierAssignmentEditor({layoutData, tiers, onChange}: TierAssignmentEditorProps) {&#10;    const [selectedTierId, setSelectedTierId] = useState&lt;string | null&gt;(tiers[0]?.id || null);&#10;&#10;    const handleSeatClick = (blockId: string, rowId: string, seatId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block?.rows) {&#10;            const row = block.rows.find((r: Row) =&gt; r.id === rowId);&#10;            if (row?.seats) {&#10;                const seat = row.seats.find((s: Seat) =&gt; s.id === seatId);&#10;                if (seat) {&#10;                    if (selectedTierId === 'RESERVED') {&#10;                        seat.status = seat.status === 'RESERVED' ? 'AVAILABLE' : 'RESERVED';&#10;                        seat.tierId = undefined;&#10;                    } else {&#10;                        seat.tierId = seat.tierId === selectedTierId ? undefined : selectedTierId;&#10;                        seat.status = 'AVAILABLE';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    const handleBlockClick = (blockId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block) {&#10;            if (selectedTierId === 'RESERVED') {&#10;                toast.warning(&quot;You cannot reserve an entire standing block. To make it unavailable, please edit the layout and change its type to 'non-sellable'.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (block.seats) {&#10;                block.seats.forEach((seat: Seat) =&gt; {&#10;                    seat.tierId = selectedTierId ?? undefined;&#10;                });&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    // Apply selected tier to all seats in a seated block&#10;    const handleApplyToAllSeats = (blockId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block?.rows) {&#10;            // Handle 'RESERVED' status specially&#10;            if (selectedTierId === 'RESERVED') {&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        seat.status = 'RESERVED';&#10;                        seat.tierId = undefined;&#10;                    }&#10;                }&#10;                toast.success(`All seats in ${block.name} have been reserved`);&#10;            } else {&#10;                // Apply the selected tier to all seats&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        if (seat.status !== 'RESERVED') {&#10;                            seat.tierId = selectedTierId;&#10;                            seat.status = 'AVAILABLE';&#10;                        }&#10;                    }&#10;                }&#10;                const tierName = tiers.find(t =&gt; t.id === selectedTierId)?.name;&#10;                toast.success(`Applied ${tierName || 'selected tier'} to all available seats in ${block.name}`);&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;flex h-[70vh] border rounded-lg&quot;&gt;&#10;            &lt;main className=&quot;flex-1 relative bg-muted/20 overflow-auto&quot;&gt;&#10;                &lt;div className=&quot;relative w-full h-full p-4&quot;&gt;&#10;                    {layoutData.layout.blocks.map(block =&gt; {&#10;                        if (block.type === 'seated_grid') {&#10;                            return &lt;InteractiveDraggableBlock&#10;                                key={block.id}&#10;                                block={block}&#10;                                tiers={tiers}&#10;                                onSeatClick={handleSeatClick}&#10;                                onApplyToAllSeats={handleApplyToAllSeats}&#10;                            /&gt;;&#10;                        }&#10;                        if (block.type === 'standing_capacity') {&#10;                            return &lt;InteractiveResizableBlock&#10;                                key={block.id}&#10;                                block={block}&#10;                                tiers={tiers}&#10;                                onClick={handleBlockClick}&#10;                            /&gt;;&#10;                        }&#10;                        return (&#10;                            &lt;div key={block.id} style={{&#10;                                left: block.position.x,&#10;                                top: block.position.y,&#10;                                width: block.width,&#10;                                height: block.height&#10;                            }}&#10;                                 className=&quot;absolute p-2 bg-muted border rounded-lg flex items-center justify-center&quot;&gt;&#10;                                &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{block.name}&lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                        );&#10;                    })}&#10;                &lt;/div&gt;&#10;            &lt;/main&gt;&#10;            &lt;TierPalette tiers={tiers} selectedTierId={selectedTierId} onSelectTier={setSelectedTierId}/&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState} from 'react';&#10;import {Block, Tier} from '@/lib/validators/event';&#10;import {SessionSeatingMapRequest, Row, Seat} from '@/lib/validators/event';&#10;&#10;import {TierPalette} from './TierPalette';&#10;import {InteractiveDraggableBlock, InteractiveResizableBlock} from './InteractiveBlocks';&#10;import {toast} from 'sonner';&#10;&#10;interface TierAssignmentEditorProps {&#10;    layoutData: SessionSeatingMapRequest; // Now receiving the already-prepared layout data&#10;    tiers: Tier[];&#10;    onChange: (layout: SessionSeatingMapRequest) =&gt; void;&#10;}&#10;&#10;export function TierAssignmentEditor({layoutData, tiers, onChange}: TierAssignmentEditorProps) {&#10;    const [selectedTierId, setSelectedTierId] = useState&lt;string | null&gt;(tiers[0]?.id || null);&#10;&#10;    const handleSeatClick = (blockId: string, rowId: string, seatId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block?.rows) {&#10;            const row = block.rows.find((r: Row) =&gt; r.id === rowId);&#10;            if (row?.seats) {&#10;                const seat = row.seats.find((s: Seat) =&gt; s.id === seatId);&#10;                if (seat) {&#10;                    if (selectedTierId === 'RESERVED') {&#10;                        seat.status = seat.status === 'RESERVED' ? 'AVAILABLE' : 'RESERVED';&#10;                        seat.tierId = undefined;&#10;                    } else {&#10;                        seat.tierId = seat.tierId === selectedTierId ? undefined : selectedTierId;&#10;                        seat.status = 'AVAILABLE';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    const handleBlockClick = (blockId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block) {&#10;            if (selectedTierId === 'RESERVED') {&#10;                toast.warning(&quot;You cannot reserve an entire standing block. To make it unavailable, please edit the layout and change its type to 'non-sellable'.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (block.seats) {&#10;                block.seats.forEach((seat: Seat) =&gt; {&#10;                    seat.tierId = selectedTierId ?? undefined;&#10;                });&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    // Apply selected tier to all seats in a seated block&#10;    const handleApplyToAllSeats = (blockId: string) =&gt; {&#10;        // Deep copy to avoid state mutation issues&#10;        const newLayout = JSON.parse(JSON.stringify(layoutData));&#10;        const block = newLayout.layout.blocks.find((b: Block) =&gt; b.id === blockId);&#10;&#10;        if (block?.rows) {&#10;            // Handle 'RESERVED' status specially&#10;            if (selectedTierId === 'RESERVED') {&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        seat.status = 'RESERVED';&#10;                        seat.tierId = undefined;&#10;                    }&#10;                }&#10;                toast.success(`All seats in ${block.name} have been reserved`);&#10;            } else {&#10;                // Apply the selected tier to all seats&#10;                for (const row of block.rows) {&#10;                    for (const seat of row.seats) {&#10;                        if (seat.status !== 'RESERVED') {&#10;                            seat.tierId = selectedTierId;&#10;                            seat.status = 'AVAILABLE';&#10;                        }&#10;                    }&#10;                }&#10;                const tierName = tiers.find(t =&gt; t.id === selectedTierId)?.name;&#10;                toast.success(`Applied ${tierName || 'selected tier'} to all available seats in ${block.name}`);&#10;            }&#10;        }&#10;&#10;        onChange(newLayout);&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;flex h-[70vh] border rounded-lg&quot;&gt;&#10;            &lt;main className=&quot;flex-1 relative bg-muted/20 overflow-auto&quot;&gt;&#10;                &lt;div className=&quot;relative w-full h-full p-4&quot;&gt;&#10;                    {layoutData.layout.blocks.map(block =&gt; {&#10;                        if (block.type === 'seated_grid') {&#10;                            return &lt;InteractiveDraggableBlock&#10;                                key={block.id}&#10;                                block={block}&#10;                                tiers={tiers}&#10;                                onSeatClick={handleSeatClick}&#10;                                onApplyToAllSeats={handleApplyToAllSeats}&#10;                            /&gt;;&#10;                        }&#10;                        if (block.type === 'standing_capacity') {&#10;                            return &lt;InteractiveResizableBlock&#10;                                key={block.id}&#10;                                block={block}&#10;                                tiers={tiers}&#10;                                onClick={handleBlockClick}&#10;                            /&gt;;&#10;                        }&#10;                        return (&#10;                            &lt;div key={block.id} style={{&#10;                                left: block.position.x,&#10;                                top: block.position.y,&#10;                                width: block.width ? block.width : undefined,&#10;                                height: block.height ? block.height : undefined&#10;                            }}&#10;                                 className=&quot;absolute p-2 bg-muted border rounded-lg flex items-center justify-center&quot;&gt;&#10;                                &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{block.name}&lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                        );&#10;                    })}&#10;                &lt;/div&gt;&#10;            &lt;/main&gt;&#10;            &lt;TierPalette tiers={tiers} selectedTierId={selectedTierId} onSelectTier={setSelectedTierId}/&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/coreDetailsStep.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/coreDetailsStep.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect, useRef} from 'react';&#10;import {useForm, FormProvider} from 'react-hook-form';&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {useOrganization} from '@/providers/OrganizationProvider';&#10;import {useLimits} from '@/providers/LimitProvider';&#10;import {CategoryResponse} from '@/types/category';&#10;import {getAllCategories} from '@/lib/actions/categoryActions';&#10;import {coreDetailsSchema, CoreDetailsData} from '@/lib/validators/event';&#10;&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Textarea} from '@/components/ui/textarea';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {&#10;    Select,&#10;    SelectContent,&#10;    SelectItem,&#10;    SelectTrigger,&#10;    SelectValue,&#10;    SelectGroup,&#10;    SelectLabel&#10;} from '@/components/ui/select';&#10;import {Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious} from &quot;@/components/ui/carousel&quot;;&#10;import Image from 'next/image';&#10;import {ImageIcon, X, PlusCircle, Upload} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import Autoplay from 'embla-carousel-autoplay';&#10;&#10;// --- Step 1: Core Details Component ---&#10;export function CoreDetailsStep({onNextAction}: { onNextAction: () =&gt; void }) {&#10;    const {organization} = useOrganization();&#10;    const {myLimits} = useLimits();&#10;    const [categories, setCategories] = useState&lt;CategoryResponse[]&gt;([]);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;    const maxPhotos = myLimits?.eventLimits.maxCoverPhotos || 1;&#10;&#10;    const form = useForm&lt;CoreDetailsData&gt;({&#10;        resolver: zodResolver(coreDetailsSchema),&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            categoryId: '', // Ensure categoryId is present&#10;            isOnline: false,&#10;        },&#10;    });&#10;&#10;    useEffect(() =&gt; {&#10;        getAllCategories().then(setCategories);&#10;    }, [organization]);&#10;&#10;    const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;        if (e.target.files) {&#10;            const files = Array.from(e.target.files);&#10;            if ((coverFiles.length + files.length) &gt; maxPhotos) {&#10;                toast.error(`You can only upload a maximum of ${maxPhotos} photos.`);&#10;                return;&#10;            }&#10;            setCoverFiles(prev =&gt; [...prev, ...files]);&#10;        }&#10;    };&#10;&#10;    const removeImage = (index: number) =&gt; {&#10;        setCoverFiles(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;    };&#10;&#10;    function onSubmit(data: CoreDetailsData) {&#10;        console.log(&quot;Step 1 Data:&quot;, data);&#10;        console.log(&quot;Cover Files:&quot;, coverFiles);&#10;        onNextAction();&#10;    }&#10;&#10;    return (&#10;        &lt;FormProvider {...form}&gt;&#10;            &lt;form onSubmit={form.handleSubmit(onSubmit)} className=&quot;space-y-8&quot;&gt;&#10;                {/* Hero Cover Photos Section */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Cover Photos&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;This is the first thing people will see. Upload up&#10;                            to {maxPhotos} images.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent&gt;&#10;                        {coverFiles.length &gt; 0 ? (&#10;                            &lt;Carousel plugins={[Autoplay({delay: 4000, stopOnInteraction: false})]}&gt;&#10;                                &lt;CarouselContent&gt;&#10;                                    {coverFiles.map((file, index) =&gt; (&#10;                                        &lt;CarouselItem key={index} className=&quot;relative&quot;&gt;&#10;                                            &lt;div className=&quot;aspect-[21/9] w-full relative&quot;&gt;&#10;                                                &lt;Image src={URL.createObjectURL(file)} alt={`Cover photo ${index + 1}`}&#10;                                                       fill className=&quot;object-cover rounded-lg&quot;/&gt;&#10;                                                &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot;&#10;                                                        className=&quot;absolute top-4 right-4 h-8 w-8 z-10&quot;&#10;                                                        onClick={() =&gt; removeImage(index)}&gt;&lt;X&#10;                                                    className=&quot;h-4 w-4&quot;/&gt;&lt;/Button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/CarouselItem&gt;&#10;                                    ))}&#10;                                &lt;/CarouselContent&gt;&#10;                                &lt;CarouselPrevious type=&quot;button&quot;&#10;                                                  className=&quot;absolute left-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                                &lt;CarouselNext type=&quot;button&quot;&#10;                                              className=&quot;absolute right-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                            &lt;/Carousel&gt;&#10;                        ) : (&#10;                            &lt;div&#10;                                className=&quot;flex flex-col items-center justify-center border-2 border-dashed rounded-lg p-12 text-center aspect-[21/9] w-full&quot;&gt;&#10;                                &lt;ImageIcon className=&quot;h-16 w-16 text-muted-foreground&quot;/&gt;&#10;                                &lt;p className=&quot;mt-4 text-lg font-medium&quot;&gt;Add cover photos for your event&lt;/p&gt;&#10;                                &lt;Button type=&quot;button&quot; className=&quot;mt-4&quot;&#10;                                        onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;Upload className=&quot;mr-2 h-4 w-4&quot;/&gt;Upload&#10;                                    Images&lt;/Button&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;                        &lt;div className=&quot;mt-4 flex justify-center items-center gap-4&quot;&gt;&#10;                            {coverFiles.length &gt; 0 &amp;&amp; (&lt;Button type=&quot;button&quot; variant=&quot;outline&quot;&#10;                                                               onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;PlusCircle&#10;                                className=&quot;mr-2 h-4 w-4&quot;/&gt;Add More&lt;/Button&gt;)}&#10;                            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{coverFiles.length} of {maxPhotos} photos&#10;                                selected.&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;Input id=&quot;picture&quot; type=&quot;file&quot; multiple accept=&quot;image/*&quot; onChange={handleFileChange}&#10;                               className=&quot;hidden&quot; ref={fileInputRef}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;&#10;                {/* Event Details Card with Category dropdown */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Event Details&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;Provide the core information about your event.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                        &lt;FormField control={form.control} name=&quot;title&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Event Title&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                placeholder=&quot;e.g., Annual Tech Conference 2025&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;&#10;                        {/* Category Selector as dropdown */}&#10;                        &lt;FormField&#10;                            control={form.control}&#10;                            name=&quot;categoryId&quot;&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Category&lt;/FormLabel&gt;&#10;                                    &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                        &lt;FormControl&gt;&#10;                                            &lt;SelectTrigger&gt;&#10;                                                &lt;SelectValue placeholder=&quot;Select a category for your event&quot;/&gt;&#10;                                            &lt;/SelectTrigger&gt;&#10;                                        &lt;/FormControl&gt;&#10;                                        &lt;SelectContent className=&quot;max-h-100&quot;&gt;&#10;                                            {categories.map((parentCat) =&gt; (&#10;                                                &lt;SelectGroup key={parentCat.id}&gt;&#10;                                                    &lt;SelectLabel&gt;{parentCat.name}&lt;/SelectLabel&gt;&#10;                                                    {parentCat.subCategories.map((subCat) =&gt; (&#10;                                                        &lt;SelectItem key={subCat.id} value={subCat.id}&gt;&#10;                                                            {subCat.name}&#10;                                                        &lt;/SelectItem&gt;&#10;                                                    ))}&#10;                                                &lt;/SelectGroup&gt;&#10;                                            ))}&#10;                                        &lt;/SelectContent&gt;&#10;                                    &lt;/Select&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;&#10;                        &lt;FormField control={form.control} name=&quot;description&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Short Description&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;A brief summary of your event.&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                        &lt;FormField control={form.control} name=&quot;overview&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Overview&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;Provide more details like schedule, speakers, etc.&quot;&#10;                                className=&quot;min-h-32&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;                &lt;div className=&quot;flex justify-end mt-8&quot;&gt;&#10;                    &lt;Button type=&quot;submit&quot;&gt;Next: Tiers &amp; Pricing&lt;/Button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/form&gt;&#10;        &lt;/FormProvider&gt;&#10;    )&#10;}" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect, useRef} from 'react';&#10;import {useForm, FormProvider} from 'react-hook-form';&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {useOrganization} from '@/providers/OrganizationProvider';&#10;import {useLimits} from '@/providers/LimitProvider';&#10;import {CategoryResponse} from '@/types/category';&#10;import {getAllCategories} from '@/lib/actions/categoryActions';&#10;import {coreDetailsSchema, CoreDetailsData} from '@/lib/validators/event';&#10;&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Textarea} from '@/components/ui/textarea';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {&#10;    Select,&#10;    SelectContent,&#10;    SelectItem,&#10;    SelectTrigger,&#10;    SelectValue,&#10;    SelectGroup,&#10;    SelectLabel&#10;} from '@/components/ui/select';&#10;import {Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious} from &quot;@/components/ui/carousel&quot;;&#10;import Image from 'next/image';&#10;import {ImageIcon, X, PlusCircle, Upload} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import Autoplay from 'embla-carousel-autoplay';&#10;&#10;// Updated props interface to match the required signature&#10;interface CoreDetailsStepProps {&#10;    coverFiles: File[];&#10;    setCoverFilesAction: React.Dispatch&lt;React.SetStateAction&lt;File[]&gt;&gt;;&#10;    onNextAction?: () =&gt; void;&#10;}&#10;&#10;// --- Step 1: Core Details Component ---&#10;export function CoreDetailsStep({ coverFiles, setCoverFilesAction, onNextAction }: CoreDetailsStepProps) {&#10;    const {organization} = useOrganization();&#10;    const {myLimits} = useLimits();&#10;    const [categories, setCategories] = useState&lt;CategoryResponse[]&gt;([]);&#10;    const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;    const maxPhotos = myLimits?.eventLimits.maxCoverPhotos || 1;&#10;&#10;    const form = useForm&lt;CoreDetailsData&gt;({&#10;        resolver: zodResolver(coreDetailsSchema),&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            categoryId: '', // Ensure categoryId is present&#10;            isOnline: false,&#10;        },&#10;    });&#10;&#10;    useEffect(() =&gt; {&#10;        getAllCategories().then(setCategories);&#10;    }, [organization]);&#10;&#10;    const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;        if (e.target.files) {&#10;            const files = Array.from(e.target.files);&#10;            if ((coverFiles.length + files.length) &gt; maxPhotos) {&#10;                toast.error(`You can only upload a maximum of ${maxPhotos} photos.`);&#10;                return;&#10;            }&#10;            setCoverFilesAction(prev =&gt; [...prev, ...files]);&#10;        }&#10;    };&#10;&#10;    const removeImage = (index: number) =&gt; {&#10;        setCoverFilesAction(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;    };&#10;&#10;    function onSubmit(data: CoreDetailsData) {&#10;        console.log(&quot;Step 1 Data:&quot;, data);&#10;        console.log(&quot;Cover Files:&quot;, coverFiles);&#10;        if (onNextAction) onNextAction();&#10;    }&#10;&#10;    return (&#10;        &lt;FormProvider {...form}&gt;&#10;            &lt;form onSubmit={form.handleSubmit(onSubmit)} className=&quot;space-y-8&quot;&gt;&#10;                {/* Hero Cover Photos Section */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Cover Photos&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;This is the first thing people will see. Upload up&#10;                            to {maxPhotos} images.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent&gt;&#10;                        {coverFiles.length &gt; 0 ? (&#10;                            &lt;Carousel plugins={[Autoplay({delay: 4000, stopOnInteraction: false})]}&gt;&#10;                                &lt;CarouselContent&gt;&#10;                                    {coverFiles.map((file, index) =&gt; (&#10;                                        &lt;CarouselItem key={index} className=&quot;relative&quot;&gt;&#10;                                            &lt;div className=&quot;aspect-[21/9] w-full relative&quot;&gt;&#10;                                                &lt;Image src={URL.createObjectURL(file)} alt={`Cover photo ${index + 1}`}&#10;                                                       fill className=&quot;object-cover rounded-lg&quot;/&gt;&#10;                                                &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot;&#10;                                                        className=&quot;absolute top-4 right-4 h-8 w-8 z-10&quot;&#10;                                                        onClick={() =&gt; removeImage(index)}&gt;&lt;X&#10;                                                    className=&quot;h-4 w-4&quot;/&gt;&lt;/Button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/CarouselItem&gt;&#10;                                    ))}&#10;                                &lt;/CarouselContent&gt;&#10;                                &lt;CarouselPrevious type=&quot;button&quot;&#10;                                                  className=&quot;absolute left-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                                &lt;CarouselNext type=&quot;button&quot;&#10;                                              className=&quot;absolute right-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                            &lt;/Carousel&gt;&#10;                        ) : (&#10;                            &lt;div&#10;                                className=&quot;flex flex-col items-center justify-center border-2 border-dashed rounded-lg p-12 text-center aspect-[21/9] w-full&quot;&gt;&#10;                                &lt;ImageIcon className=&quot;h-16 w-16 text-muted-foreground&quot;/&gt;&#10;                                &lt;p className=&quot;mt-4 text-lg font-medium&quot;&gt;Add cover photos for your event&lt;/p&gt;&#10;                                &lt;Button type=&quot;button&quot; className=&quot;mt-4&quot;&#10;                                        onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;Upload className=&quot;mr-2 h-4 w-4&quot;/&gt;Upload&#10;                                    Images&lt;/Button&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;                        &lt;div className=&quot;mt-4 flex justify-center items-center gap-4&quot;&gt;&#10;                            {coverFiles.length &gt; 0 &amp;&amp; (&lt;Button type=&quot;button&quot; variant=&quot;outline&quot;&#10;                                                               onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;PlusCircle&#10;                                className=&quot;mr-2 h-4 w-4&quot;/&gt;Add More&lt;/Button&gt;)}&#10;                            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{coverFiles.length} of {maxPhotos} photos&#10;                                selected.&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;Input id=&quot;picture&quot; type=&quot;file&quot; multiple accept=&quot;image/*&quot; onChange={handleFileChange}&#10;                               className=&quot;hidden&quot; ref={fileInputRef}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;&#10;                {/* Event Details Card with Category dropdown */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Event Details&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;Provide the core information about your event.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                        &lt;FormField control={form.control} name=&quot;title&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Event Title&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                placeholder=&quot;e.g., Annual Tech Conference 2025&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;&#10;                        {/* Category Selector as dropdown */}&#10;                        &lt;FormField&#10;                            control={form.control}&#10;                            name=&quot;categoryId&quot;&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Category&lt;/FormLabel&gt;&#10;                                    &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                        &lt;FormControl&gt;&#10;                                            &lt;SelectTrigger&gt;&#10;                                                &lt;SelectValue placeholder=&quot;Select a category for your event&quot;/&gt;&#10;                                            &lt;/SelectTrigger&gt;&#10;                                        &lt;/FormControl&gt;&#10;                                        &lt;SelectContent className=&quot;max-h-100&quot;&gt;&#10;                                            {categories.map((parentCat) =&gt; (&#10;                                                &lt;SelectGroup key={parentCat.id}&gt;&#10;                                                    &lt;SelectLabel&gt;{parentCat.name}&lt;/SelectLabel&gt;&#10;                                                    {parentCat.subCategories.map((subCat) =&gt; (&#10;                                                        &lt;SelectItem key={subCat.id} value={subCat.id}&gt;&#10;                                                            {subCat.name}&#10;                                                        &lt;/SelectItem&gt;&#10;                                                    ))}&#10;                                                &lt;/SelectGroup&gt;&#10;                                            ))}&#10;                                        &lt;/SelectContent&gt;&#10;                                    &lt;/Select&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;&#10;                        &lt;FormField control={form.control} name=&quot;description&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Short Description&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;A brief summary of your event.&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                        &lt;FormField control={form.control} name=&quot;overview&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Overview&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;Provide more details like schedule, speakers, etc.&quot;&#10;                                className=&quot;min-h-32&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;                &lt;div className=&quot;flex justify-end mt-8&quot;&gt;&#10;                    &lt;Button type=&quot;submit&quot;&gt;Next: Tiers &amp; Pricing&lt;/Button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/form&gt;&#10;        &lt;/FormProvider&gt;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/physical-config/DeleteConfirmationDialog.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/physical-config/DeleteConfirmationDialog.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;;&#10;import {&#10;    AlertDialog,&#10;    AlertDialogAction,&#10;    AlertDialogCancel,&#10;    AlertDialogContent,&#10;    AlertDialogDescription,&#10;    AlertDialogFooter,&#10;    AlertDialogHeader,&#10;    AlertDialogTitle&#10;} from &quot;@/components/ui/alert-dialog&quot;;&#10;&#10;interface DeleteConfirmationDialogProps {&#10;    isOpen: boolean;&#10;    onOpenChange: (open: boolean) =&gt; void;&#10;    layoutName: string | undefined;&#10;    onConfirmDelete: () =&gt; void;&#10;}&#10;&#10;export function DeleteConfirmationDialog({&#10;    isOpen,&#10;    onOpenChange,&#10;    layoutName,&#10;    onConfirmDelete&#10;}: DeleteConfirmationDialogProps) {&#10;    return (&#10;        &lt;AlertDialog open={isOpen} onOpenChange={onOpenChange}&gt;&#10;            &lt;AlertDialogContent&gt;&#10;                &lt;AlertDialogHeader&gt;&#10;                    &lt;AlertDialogTitle&gt;Delete Layout Template&lt;/AlertDialogTitle&gt;&#10;                    &lt;AlertDialogDescription&gt;&#10;                        Are you sure you want to delete &amp;#34;{layoutName}&amp;#34;? This action cannot be undone.&#10;                    &lt;/AlertDialogDescription&gt;&#10;                &lt;/AlertDialogHeader&gt;&#10;                &lt;AlertDialogFooter&gt;&#10;                    &lt;AlertDialogCancel&gt;Cancel&lt;/AlertDialogCancel&gt;&#10;                    &lt;AlertDialogAction&#10;                        onClick={onConfirmDelete}&#10;                        className=&quot;bg-destructive text-destructive-foreground hover:bg-destructive/90&quot;&#10;                    &gt;&#10;                        Delete&#10;                    &lt;/AlertDialogAction&gt;&#10;                &lt;/AlertDialogFooter&gt;&#10;            &lt;/AlertDialogContent&gt;&#10;        &lt;/AlertDialog&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/physical-config/ProgressSteps.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/physical-config/ProgressSteps.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;;&#10;import {CheckCircle2} from &quot;lucide-react&quot;;&#10;import {cn} from &quot;@/lib/utils&quot;;&#10;&#10;type Step = {&#10;    id: string;&#10;    label: string;&#10;}&#10;&#10;interface ProgressStepsProps {&#10;    steps: Step[];&#10;    currentMode: string;&#10;    onStepClick: (step: string) =&gt; void;&#10;}&#10;&#10;export function ProgressSteps({ steps, currentMode, onStepClick }: ProgressStepsProps) {&#10;    return (&#10;        &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;div className=&quot;flex items-center justify-center&quot;&gt;&#10;                {steps.map((step, idx) =&gt; {&#10;                    // Determine if this step is clickable (can't skip ahead, but can go back)&#10;                    const currentStepIndex = steps.findIndex(s =&gt; s.id === currentMode);&#10;                    const isClickable = idx &lt;= currentStepIndex;&#10;&#10;                    return (&#10;                        &lt;React.Fragment key={step.id}&gt;&#10;                            {/* Step indicator */}&#10;                            &lt;div&#10;                                className={cn(&#10;                                    &quot;flex flex-col items-center&quot;,&#10;                                    isClickable &amp;&amp; &quot;cursor-pointer&quot;&#10;                                )}&#10;                                onClick={() =&gt; {&#10;                                    if (!isClickable) return;&#10;                                    onStepClick(step.id);&#10;                                }}&#10;                            &gt;&#10;                                &lt;div&#10;                                    className={cn(&#10;                                        &quot;flex items-center justify-center h-8 w-8 rounded-full border-2&quot;,&#10;                                        currentMode === step.id&#10;                                            ? &quot;border-primary bg-primary text-primary-foreground&quot;&#10;                                            : idx &lt; steps.findIndex(s =&gt; s.id === currentMode)&#10;                                                ? &quot;border-primary bg-primary/10 text-primary&quot;&#10;                                                : &quot;border-muted-foreground text-muted-foreground&quot;&#10;                                    )}&#10;                                &gt;&#10;                                    {idx &lt; steps.findIndex(s =&gt; s.id === currentMode) ? (&#10;                                        &lt;CheckCircle2 className=&quot;h-5 w-5&quot;/&gt;&#10;                                    ) : (&#10;                                        &lt;span&gt;{idx + 1}&lt;/span&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                                &lt;span className={cn(&#10;                                    &quot;text-xs mt-1&quot;,&#10;                                    currentMode === step.id ? &quot;text-primary font-medium&quot; : &quot;text-muted-foreground&quot;&#10;                                )}&gt;&#10;                                    {step.label}&#10;                                &lt;/span&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            {/* Connector line between steps */}&#10;                            {idx &lt; steps.length - 1 &amp;&amp; (&#10;                                &lt;div&#10;                                    className={cn(&#10;                                        &quot;w-12 h-[2px] mx-1&quot;,&#10;                                        idx &lt; steps.findIndex(s =&gt; s.id === currentMode)&#10;                                            ? &quot;bg-primary&quot;&#10;                                            : &quot;bg-muted-foreground/30&quot;&#10;                                    )}&#10;                                /&gt;&#10;                            )}&#10;                        &lt;/React.Fragment&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect} from 'react';&#10;import {CoreDetailsStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/CoreDetailsStep&quot;;&#10;import {Progress} from &quot;@/components/ui/progress&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {FormProvider, useForm} from &quot;react-hook-form&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {TiersStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierStep&quot;;&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {CreateEventFormData, createEventSchema, stepValidationFields} from '@/lib/validators/event';&#10;import {SchedulingStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/SchedulingStep&quot;;&#10;import {SeatingStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/SeatingStep&quot;;&#10;import {useOrganization} from &quot;@/providers/OrganizationProvider&quot;;&#10;import {ReviewStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/ReviewStep&quot;;&#10;import {&#10;    AlertDialog,&#10;    AlertDialogAction, AlertDialogCancel,&#10;    AlertDialogContent,&#10;    AlertDialogDescription,&#10;    AlertDialogFooter,&#10;    AlertDialogHeader,&#10;    AlertDialogTitle, AlertDialogTrigger,&#10;} from &quot;@/components/ui/alert-dialog&quot;;&#10;&#10;&#10;export default function CreateEventPage() {&#10;    const [step, setStep] = useState(1);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const [inConfigMode, setInConfigMode] = useState(false);&#10;    const [showApprovalDialog, setShowApprovalDialog] = useState(false);&#10;    const {&#10;        organization: activeOrganization,&#10;    } = useOrganization();&#10;    const totalSteps = 5;&#10;&#10;    const methods = useForm&lt;CreateEventFormData&gt;({&#10;        resolver: zodResolver(createEventSchema),&#10;        mode: 'onChange', // Enable real-time validation&#10;        defaultValues: {&#10;            title: 'An Example Event',&#10;            description: 'This is a sample event description.',&#10;            overview: 'An overview of the event goes here.',&#10;            organizationId: activeOrganization?.id || '', // This might be undefined initially&#10;            categoryId: '',&#10;            tiers: [],&#10;            sessions: [],&#10;        },&#10;    });&#10;&#10;    // Update organizationId when activeOrganization becomes available&#10;    useEffect(() =&gt; {&#10;        if (activeOrganization?.id) {&#10;            methods.setValue('organizationId', activeOrganization.id);&#10;        }&#10;    }, [activeOrganization, methods]);&#10;&#10;    const onNext = async () =&gt; {&#10;        const fieldsToValidate = stepValidationFields[step as keyof typeof stepValidationFields];&#10;        const isValid = await methods.trigger(fieldsToValidate);&#10;        console.log(methods.watch());&#10;&#10;        if (isValid) {&#10;            setStep(s =&gt; Math.min(totalSteps, s + 1));&#10;        } else {&#10;            // react-hook-form will automatically show errors next to the invalid fields.&#10;            // A toast is good for a general notification.&#10;            console.log(&quot;Validation errors for step&quot;, step, methods.formState.errors);&#10;            console.error(&quot;Validation failed for step&quot;, step);&#10;            toast.error(&quot;Please fix the errors before proceeding.&quot;);&#10;        }&#10;    };&#10;&#10;    const onPrev = () =&gt; setStep(s =&gt; Math.max(1, s - 1));&#10;&#10;    const onSubmit = (data: CreateEventFormData) =&gt; {&#10;        console.log(&quot;Final Assembled Form Data:&quot;, data);&#10;        console.log(&quot;Final Cover Files:&quot;, coverFiles);&#10;        // 2s delay to simulate API call&#10;        toast.loading(&quot;Submitting event...&quot;);&#10;        setTimeout(() =&gt; {&#10;            toast.dismiss();&#10;            toast.success(&quot;Event created successfully!&quot;);&#10;            // Reset form and cover files after successful submission&#10;            // methods.reset();&#10;            // setCoverFiles([]);&#10;            // setStep(1); // Reset to the first step&#10;        }, 2000);&#10;    };&#10;&#10;&#10;    const renderStep = () =&gt; {&#10;        switch (step) {&#10;            case 1:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;            case 2:&#10;                return &lt;TiersStep/&gt;;&#10;            // Add cases for other steps here&#10;            case 3:&#10;                return &lt;SchedulingStep/&gt;&#10;            case 4:&#10;                return &lt;SeatingStep onConfigModeChange={setInConfigMode}/&gt;;&#10;            case 5:&#10;                return &lt;ReviewStep coverFiles={coverFiles}/&gt;; //  Render the new step&#10;            default:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;        }&#10;    };&#10;&#10;    // Helper function to check if current step has errors&#10;    const hasStepErrors = () =&gt; {&#10;        const fieldsToCheck = stepValidationFields[step as keyof typeof stepValidationFields];&#10;        if (!fieldsToCheck) return false;&#10;&#10;        return fieldsToCheck.some(field =&gt; methods.formState.errors[field]);&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;p-4 md:p-8&quot;&gt;&#10;            &lt;div className=&quot;mb-8&quot;&gt;&#10;                &lt;div className=&quot;flex justify-between items-center&quot;&gt;&#10;                    &lt;div&gt;&#10;                        &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Create New Event&lt;/h1&gt;&#10;                        &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;Step {step} of {totalSteps}&lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                    {hasStepErrors() &amp;&amp; (&#10;                        &lt;div className=&quot;text-sm text-destructive&quot;&gt;&#10;                            Please fix validation errors&#10;                        &lt;/div&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;                &lt;Progress value={(step / totalSteps) * 100} className=&quot;mt-2&quot;/&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;FormProvider {...methods}&gt;&#10;                &lt;form onSubmit={methods.handleSubmit(onSubmit)}&gt;&#10;                    {renderStep()}&#10;&#10;                    {/* Hide the Next/Previous buttons when in configuration mode */}&#10;                    {!inConfigMode &amp;&amp; (&#10;                        &lt;div className=&quot;flex justify-between mt-8&quot;&gt;&#10;                            &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={onPrev} disabled={step === 1}&gt;&#10;                                Previous&#10;                            &lt;/Button&gt;&#10;                            {step &lt; totalSteps ? (&#10;                                &lt;Button&#10;                                    type=&quot;button&quot;&#10;                                    onClick={onNext}&#10;                                    disabled={methods.formState.isSubmitting}&#10;                                &gt;&#10;                                    {methods.formState.isSubmitting ? 'Validating...' : 'Next'}&#10;                                &lt;/Button&gt;&#10;                            ) : (&#10;                                &lt;AlertDialog open={showApprovalDialog} onOpenChange={setShowApprovalDialog}&gt;&#10;                                    &lt;AlertDialogTrigger asChild&gt;&#10;                                        &lt;Button type=&quot;button&quot; disabled={methods.formState.isSubmitting}&gt;&#10;                                            Submit Event&#10;                                        &lt;/Button&gt;&#10;                                    &lt;/AlertDialogTrigger&gt;&#10;                                    &lt;AlertDialogContent&gt;&#10;                                        &lt;AlertDialogHeader&gt;&#10;                                            &lt;AlertDialogTitle&gt;Are you sure?&lt;/AlertDialogTitle&gt;&#10;                                            &lt;AlertDialogDescription&gt;&#10;                                                You are about to submit your event for approval. Please ensure all&#10;                                                details are correct.&#10;                                                Once submitted, you will not be able to make changes until the event is&#10;                                                approved by an admin.&#10;                                                &lt;br/&gt;&#10;                                                &lt;br/&gt;&#10;                                                &lt;strong&gt;Event Title:&lt;/strong&gt; {methods.watch('title')}&#10;                                                &lt;br/&gt;&#10;                                                &lt;strong&gt;Organization:&lt;/strong&gt; {activeOrganization?.name || 'N/A'}&#10;                                            &lt;/AlertDialogDescription&gt;&#10;                                        &lt;/AlertDialogHeader&gt;&#10;                                        &lt;AlertDialogFooter&gt;&#10;                                            &lt;AlertDialogAction onClick={() =&gt; {&#10;                                                setShowApprovalDialog(false);&#10;                                                onSubmit(methods.getValues());&#10;                                            }}&gt;&#10;                                                Confirm and Submit&#10;                                            &lt;/AlertDialogAction&gt;&#10;                                            &lt;AlertDialogCancel&gt;&#10;                                                Cancel&#10;                                            &lt;/AlertDialogCancel&gt;&#10;                                        &lt;/AlertDialogFooter&gt;&#10;                                    &lt;/AlertDialogContent&gt;&#10;                                &lt;/AlertDialog&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;                    )}&#10;                &lt;/form&gt;&#10;            &lt;/FormProvider&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect} from 'react';&#10;import {CoreDetailsStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/CoreDetailsStep&quot;;&#10;import {Progress} from &quot;@/components/ui/progress&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {FormProvider, useForm} from &quot;react-hook-form&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {TiersStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierStep&quot;;&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {CreateEventFormData, createEventSchema, stepValidationFields} from '@/lib/validators/event';&#10;import {SchedulingStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/SchedulingStep&quot;;&#10;import {SeatingStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/SeatingStep&quot;;&#10;import {useOrganization} from &quot;@/providers/OrganizationProvider&quot;;&#10;import {ReviewStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/ReviewStep&quot;;&#10;import {&#10;    AlertDialog,&#10;    AlertDialogAction, AlertDialogCancel,&#10;    AlertDialogContent,&#10;    AlertDialogDescription,&#10;    AlertDialogFooter,&#10;    AlertDialogHeader,&#10;    AlertDialogTitle, AlertDialogTrigger,&#10;} from &quot;@/components/ui/alert-dialog&quot;;&#10;import { createEvent } from &quot;@/lib/actions/eventActions&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;&#10;&#10;export default function CreateEventPage() {&#10;    const [step, setStep] = useState(1);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const [inConfigMode, setInConfigMode] = useState(false);&#10;    const [showApprovalDialog, setShowApprovalDialog] = useState(false);&#10;    const [isSubmitting, setIsSubmitting] = useState(false);&#10;    const router = useRouter();&#10;&#10;    const {&#10;        organization: activeOrganization,&#10;    } = useOrganization();&#10;    const totalSteps = 5;&#10;&#10;    const methods = useForm&lt;CreateEventFormData&gt;({&#10;        resolver: zodResolver(createEventSchema),&#10;        mode: 'onChange', // Enable real-time validation&#10;        defaultValues: {&#10;            title: 'An Example Event',&#10;            description: 'This is a sample event description.',&#10;            overview: 'An overview of the event goes here.',&#10;            organizationId: activeOrganization?.id || '', // This might be undefined initially&#10;            categoryId: '',&#10;            tiers: [],&#10;            sessions: [],&#10;        },&#10;    });&#10;&#10;    // Update organizationId when activeOrganization becomes available&#10;    useEffect(() =&gt; {&#10;        if (activeOrganization?.id) {&#10;            methods.setValue('organizationId', activeOrganization.id);&#10;        }&#10;    }, [activeOrganization, methods]);&#10;&#10;    const onNext = async () =&gt; {&#10;        const fieldsToValidate = stepValidationFields[step as keyof typeof stepValidationFields];&#10;        const isValid = await methods.trigger(fieldsToValidate);&#10;        console.log(methods.watch());&#10;&#10;        if (isValid) {&#10;            setStep(s =&gt; Math.min(totalSteps, s + 1));&#10;        } else {&#10;            // react-hook-form will automatically show errors next to the invalid fields.&#10;            // A toast is good for a general notification.&#10;            console.log(&quot;Validation errors for step&quot;, step, methods.formState.errors);&#10;            console.error(&quot;Validation failed for step&quot;, step);&#10;            toast.error(&quot;Please fix the errors before proceeding.&quot;);&#10;        }&#10;    };&#10;&#10;    const onPrev = () =&gt; setStep(s =&gt; Math.max(1, s - 1));&#10;&#10;    const onSubmit = async (data: CreateEventFormData) =&gt; {&#10;        setIsSubmitting(true);&#10;        const loadingToast = toast.loading(&quot;Submitting your event...&quot;);&#10;        &#10;        try {&#10;            console.log(&quot;Submitting event data:&quot;, data);&#10;            console.log(&quot;Cover files:&quot;, coverFiles);&#10;            &#10;            // Call the API to create the event&#10;            const response = await createEvent(data, coverFiles);&#10;            &#10;            toast.dismiss(loadingToast);&#10;            toast.success(&quot;Event submitted successfully!&quot;);&#10;            &#10;            console.log(&quot;Event created:&quot;, response);&#10;            &#10;            // Navigate to the events page after a short delay&#10;            setTimeout(() =&gt; {&#10;                if (activeOrganization?.id) {&#10;                    router.push(`/manage/organization/${activeOrganization.id}/event`);&#10;                }&#10;            }, 1500);&#10;            &#10;        } catch (error) {&#10;            toast.dismiss(loadingToast);&#10;            console.error(&quot;Error creating event:&quot;, error);&#10;            toast.error(error instanceof Error ? error.message : &quot;Failed to create event. Please try again.&quot;);&#10;        } finally {&#10;            setIsSubmitting(false);&#10;            setShowApprovalDialog(false);&#10;        }&#10;    };&#10;&#10;&#10;    const renderStep = () =&gt; {&#10;        switch (step) {&#10;            case 1:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;            case 2:&#10;                return &lt;TiersStep/&gt;;&#10;            // Add cases for other steps here&#10;            case 3:&#10;                return &lt;SchedulingStep/&gt;&#10;            case 4:&#10;                return &lt;SeatingStep onConfigModeChange={setInConfigMode}/&gt;;&#10;            case 5:&#10;                return &lt;ReviewStep coverFiles={coverFiles}/&gt;; //  Render the new step&#10;            default:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;        }&#10;    };&#10;&#10;    // Helper function to check if current step has errors&#10;    const hasStepErrors = () =&gt; {&#10;        const fieldsToCheck = stepValidationFields[step as keyof typeof stepValidationFields];&#10;        if (!fieldsToCheck) return false;&#10;&#10;        return fieldsToCheck.some(field =&gt; methods.formState.errors[field]);&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;p-4 md:p-8&quot;&gt;&#10;            &lt;div className=&quot;mb-8&quot;&gt;&#10;                &lt;div className=&quot;flex justify-between items-center&quot;&gt;&#10;                    &lt;div&gt;&#10;                        &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Create New Event&lt;/h1&gt;&#10;                        &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;Step {step} of {totalSteps}&lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                    {hasStepErrors() &amp;&amp; (&#10;                        &lt;div className=&quot;text-sm text-destructive&quot;&gt;&#10;                            Please fix validation errors&#10;                        &lt;/div&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;                &lt;Progress value={(step / totalSteps) * 100} className=&quot;mt-2&quot;/&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;FormProvider {...methods}&gt;&#10;                &lt;form onSubmit={methods.handleSubmit(onSubmit)}&gt;&#10;                    {renderStep()}&#10;&#10;                    {/* Hide the Next/Previous buttons when in configuration mode */}&#10;                    {!inConfigMode &amp;&amp; (&#10;                        &lt;div className=&quot;flex justify-between mt-8&quot;&gt;&#10;                            &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={onPrev} disabled={step === 1}&gt;&#10;                                Previous&#10;                            &lt;/Button&gt;&#10;                            {step &lt; totalSteps ? (&#10;                                &lt;Button&#10;                                    type=&quot;button&quot;&#10;                                    onClick={onNext}&#10;                                    disabled={isSubmitting}&#10;                                &gt;&#10;                                    {isSubmitting ? 'Validating...' : 'Next'}&#10;                                &lt;/Button&gt;&#10;                            ) : (&#10;                                &lt;AlertDialog open={showApprovalDialog} onOpenChange={setShowApprovalDialog}&gt;&#10;                                    &lt;AlertDialogTrigger asChild&gt;&#10;                                        &lt;Button type=&quot;button&quot; disabled={isSubmitting}&gt;&#10;                                            Submit Event&#10;                                        &lt;/Button&gt;&#10;                                    &lt;/AlertDialogTrigger&gt;&#10;                                    &lt;AlertDialogContent&gt;&#10;                                        &lt;AlertDialogHeader&gt;&#10;                                            &lt;AlertDialogTitle&gt;Event Submission&lt;/AlertDialogTitle&gt;&#10;                                            &lt;AlertDialogDescription&gt;&#10;                                                Thank you for submitting your event. Our admin team will review your request shortly and get back to you.&#10;                                                You'll receive a notification once the review is complete.&#10;                                                &lt;br/&gt;&#10;                                                &lt;br/&gt;&#10;                                                &lt;strong&gt;Event Title:&lt;/strong&gt; {methods.watch('title')}&#10;                                                &lt;br/&gt;&#10;                                                &lt;strong&gt;Organization:&lt;/strong&gt; {activeOrganization?.name || 'N/A'}&#10;                                            &lt;/AlertDialogDescription&gt;&#10;                                        &lt;/AlertDialogHeader&gt;&#10;                                        &lt;AlertDialogFooter&gt;&#10;                                            &lt;AlertDialogAction &#10;                                                onClick={() =&gt; onSubmit(methods.getValues())}&#10;                                                disabled={isSubmitting}&#10;                                            &gt;&#10;                                                {isSubmitting ? 'Submitting...' : 'Confirm'}&#10;                                            &lt;/AlertDialogAction&gt;&#10;                                            &lt;AlertDialogCancel&gt;&#10;                                                Cancel&#10;                                            &lt;/AlertDialogCancel&gt;&#10;                                        &lt;/AlertDialogFooter&gt;&#10;                                    &lt;/AlertDialogContent&gt;&#10;                                &lt;/AlertDialog&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;                    )}&#10;                &lt;/form&gt;&#10;            &lt;/FormProvider&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx.new">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx.new" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useEffect, useState} from 'react';&#10;import {CoreDetailsStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/CoreDetailsStep&quot;;&#10;import {Progress} from &quot;@/components/ui/progress&quot;;&#10;import {CreateEventRequest} from &quot;@/types/event&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {FormProvider, useForm} from &quot;react-hook-form&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {TiersStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierStep&quot;;&#10;import {zodResolver} from &quot;@hookform/resolvers/zod&quot;;&#10;import {coreDetailsSchema, tiersSchema} from &quot;@/lib/validators/event&quot;;&#10;import {WizardSidebar} from &quot;../_components/WizardSideBar&quot;;&#10;import {useSidebar} from &quot;@/components/ui/sidebar&quot;;&#10;&#10;// --- Main Wizard Parent Component ---&#10;export default function CreateEventPage() {&#10;    const [step, setStep] = useState(1);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const totalSteps = 5;&#10;    const {setOpen} = useSidebar();&#10;    &#10;    const steps = [&#10;        {number: 1, title: &quot;Core Details&quot;, description: &quot;Name, category, and location&quot;},&#10;        {number: 2, title: &quot;Tiers &amp; Pricing&quot;, description: &quot;Set your ticket prices&quot;},&#10;        {number: 3, title: &quot;Scheduling&quot;, description: &quot;Add dates and times&quot;},&#10;        {number: 4, title: &quot;Seating&quot;, description: &quot;Configure seating maps&quot;},&#10;        {number: 5, title: &quot;Review &amp; Publish&quot;, description: &quot;Final check before submission&quot;},&#10;    ];&#10;&#10;    // Collapse the main sidebar when component mounts&#10;    useEffect(() =&gt; {&#10;        setOpen(false);&#10;    }, [setOpen]);&#10;&#10;    //  The single form instance for the entire wizard is created here.&#10;    const methods = useForm&lt;CreateEventRequest&gt;({&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            organizationId: '', // Should be set from context/params&#10;            categoryId: '',&#10;            isOnline: false,&#10;            tiers: [],&#10;            sessions: [],&#10;        },&#10;        mode: 'onSubmit', // Only validate when explicitly triggered&#10;    });&#10;&#10;    // Update the validation schema based on the current step&#10;    useEffect(() =&gt; {&#10;        if (step === 1) {&#10;            methods.clearErrors();&#10;        } else if (step === 2) {&#10;            methods.clearErrors();&#10;        }&#10;    }, [step, methods]);&#10;&#10;    const validateCoreDetails = async () =&gt; {&#10;        try {&#10;            // Check for cover photos&#10;            if (coverFiles.length === 0) {&#10;                toast.error(&quot;Please upload at least one cover photo.&quot;);&#10;                return false;&#10;            }&#10;            &#10;            // Get form values for core details&#10;            const values = methods.getValues();&#10;            const coreData = {&#10;                title: values.title,&#10;                description: values.description || &quot;&quot;,&#10;                overview: values.overview || &quot;&quot;,&#10;                categoryId: values.categoryId || &quot;&quot;,&#10;                isOnline: values.isOnline || false,&#10;                venueId: values.venueId,&#10;                onlineLink: values.onlineLink,&#10;                locationDescription: values.locationDescription,&#10;            };&#10;            &#10;            // Validate with Zod schema&#10;            const result = coreDetailsSchema.safeParse(coreData);&#10;            &#10;            if (!result.success) {&#10;                // Show validation errors&#10;                result.error.errors.forEach(err =&gt; {&#10;                    toast.error(`${err.path.join('.')}: ${err.message}`);&#10;                });&#10;                &#10;                // Also set form errors for field highlighting&#10;                result.error.errors.forEach(err =&gt; {&#10;                    const path = err.path.join('.') as keyof CreateEventRequest;&#10;                    methods.setError(path, { &#10;                        type: 'manual', &#10;                        message: err.message &#10;                    });&#10;                });&#10;                &#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        } catch (error: any) {&#10;            console.error(&quot;Validation error:&quot;, error);&#10;            toast.error(&quot;Please check all required fields&quot;);&#10;            return false;&#10;        }&#10;    };&#10;&#10;    const validateTiers = async () =&gt; {&#10;        try {&#10;            // Get tiers data&#10;            const values = methods.getValues();&#10;            const tiersData = { tiers: values.tiers || [] };&#10;            &#10;            // Validate with Zod schema&#10;            const result = tiersSchema.safeParse(tiersData);&#10;            &#10;            if (!result.success) {&#10;                // Show validation errors&#10;                result.error.errors.forEach(err =&gt; {&#10;                    toast.error(`${err.message}`);&#10;                });&#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        } catch (error: any) {&#10;            console.error(&quot;Tier validation error:&quot;, error);&#10;            toast.error(&quot;Please add at least one tier with valid information&quot;);&#10;            return false;&#10;        }&#10;    };&#10;&#10;    const onNext = async () =&gt; {&#10;        let isValid = false;&#10;        &#10;        if (step === 1) {&#10;            isValid = await validateCoreDetails();&#10;        } else if (step === 2) {&#10;            isValid = await validateTiers();&#10;        } else {&#10;            // For future steps that don't have validation yet&#10;            isValid = true;&#10;        }&#10;&#10;        if (isValid) {&#10;            setStep(s =&gt; Math.min(totalSteps, s + 1));&#10;        }&#10;    };&#10;&#10;    const onPrev = () =&gt; setStep(s =&gt; Math.max(1, s - 1));&#10;&#10;    const onSubmit = async (data: CreateEventRequest) =&gt; {&#10;        // Perform final validation before submission&#10;        let isValid = true;&#10;        &#10;        // Validate the current step first&#10;        if (step === 1) {&#10;            isValid = await validateCoreDetails();&#10;        } else if (step === 2) {&#10;            isValid = await validateTiers();&#10;        }&#10;        &#10;        if (isValid) {&#10;            console.log(&quot;Final Assembled Form Data:&quot;, data);&#10;            console.log(&quot;Final Cover Files:&quot;, coverFiles);&#10;            // Here you would call your createEvent API action&#10;            toast.success(&quot;Event submitted for approval!&quot;);&#10;        }&#10;    };&#10;&#10;    const renderStep = () =&gt; {&#10;        switch (step) {&#10;            case 1:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;            case 2:&#10;                return &lt;TiersStep/&gt;;&#10;            // Add cases for other steps here&#10;            default:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;flex min-h-screen bg-muted/40&quot;&gt;&#10;            &lt;WizardSidebar currentStep={step} steps={steps}/&gt;&#10;            &lt;main className=&quot;flex-1 p-4 md:p-8 overflow-y-auto ml-72&quot;&gt;&#10;                &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;&#10;                    &lt;div className=&quot;mb-8&quot;&gt;&#10;                        &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;Step {step} of {totalSteps}&lt;/p&gt;&#10;                        &lt;Progress value={(step / totalSteps) * 100} className=&quot;mt-2&quot;/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    {/*  The FormProvider broadcasts the form state to all children */}&#10;                    &lt;FormProvider {...methods}&gt;&#10;                        &lt;form onSubmit={methods.handleSubmit(onSubmit)}&gt;&#10;                            {renderStep()}&#10;&#10;                            &lt;div className=&quot;flex justify-between mt-8&quot;&gt;&#10;                                &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={onPrev} disabled={step === 1}&gt;&#10;                                    Previous&#10;                                &lt;/Button&gt;&#10;                                {step &lt; totalSteps ? (&#10;                                    &lt;Button type=&quot;button&quot; onClick={onNext}&gt;&#10;                                        Next&#10;                                    &lt;/Button&gt;&#10;                                ) : (&#10;                                    &lt;Button type=&quot;submit&quot;&gt;&#10;                                        Submit for Approval&#10;                                    &lt;/Button&gt;&#10;                                )}&#10;                            &lt;/div&gt;&#10;                        &lt;/form&gt;&#10;                    &lt;/FormProvider&gt;&#10;                &lt;/div&gt;&#10;            &lt;/main&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/actions/eventActions.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/actions/eventActions.ts" />
              <option name="originalContent" value="import {CreateEventFormData} from &quot;@/lib/validators/event&quot;;&#10;import {apiFetch} from '@/lib/api';&#10;&#10;/**&#10; * Type definitions based on the provided Java DTOs&#10; */&#10;&#10;export enum EventStatus {&#10;    PENDING = 'PENDING',&#10;    APPROVED = 'APPROVED',&#10;    REJECTED = 'REJECTED'&#10;}&#10;&#10;export interface EventResponseDTO {&#10;    id: string;&#10;    title: string;&#10;    status: string;&#10;    organizationId: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;}&#10;&#10;export interface EventSummaryDTO {&#10;    id: string;&#10;    title: string;&#10;    status: EventStatus;&#10;    organizationName: string;&#10;    organizationId: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;    description: string;&#10;    coverPhoto: string;&#10;    sessionCount: number;&#10;    earliestSessionDate: string;&#10;}&#10;&#10;export interface EventDetailDTO {&#10;    id: string;&#10;    title: string;&#10;    description: string;&#10;    overview: string;&#10;    status: EventStatus;&#10;    rejectionReason: string | null;&#10;    coverPhotos: string[];&#10;    organizationId: string;&#10;    organizationName: string;&#10;    categoryId: string;&#10;    categoryName: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;    tiers: TierDTO[];&#10;    sessions: SessionDetailDTO[];&#10;}&#10;&#10;export interface TierDTO {&#10;    id: string;&#10;    name: string;&#10;    color: string;&#10;    price: number;&#10;}&#10;&#10;export interface VenueDetailsDTO {&#10;    address: string;&#10;    name: string;&#10;    latitude: number | null;&#10;    longitude: number | null;&#10;}&#10;&#10;export interface SessionSeatingMapDTO {&#10;    name: string | null;&#10;    layout: {&#10;        blocks: {&#10;            id: string;&#10;            name: string;&#10;            type: 'seated_grid' | 'standing_capacity' | 'non_sellable';&#10;            position: {&#10;                x: number;&#10;                y: number;&#10;            };&#10;            rows?: {&#10;                id: string;&#10;                label: string;&#10;                seats: {&#10;                    id: string;&#10;                    label: string;&#10;                    tierId?: string;&#10;                    status?: string;&#10;                }[];&#10;            }[];&#10;            capacity?: number | null;&#10;            width?: number | null;&#10;            height?: number | null;&#10;            seats?: {&#10;                id: string;&#10;                label: string;&#10;                tierId?: string;&#10;                status?: string;&#10;            }[];&#10;        }[];&#10;    };&#10;}&#10;&#10;export interface SessionDetailDTO {&#10;    id: string;&#10;    startTime: string;&#10;    endTime: string;&#10;    isOnline: boolean;&#10;    onlineLink: string | null;&#10;    venueDetails: VenueDetailsDTO | null;&#10;    salesStartRuleType: 'IMMEDIATE' | 'ROLLING' | 'FIXED';&#10;    salesStartHoursBefore: number | null;&#10;    salesStartFixedDatetime: string | null;&#10;    status: string;&#10;    layoutData: SessionSeatingMapDTO;&#10;}&#10;&#10;export interface RejectEventRequest {&#10;    reason: string;&#10;}&#10;&#10;const API_BASE_PATH = '/event-seating/v1/events';&#10;&#10;/**&#10; * Create a new event&#10; * @param eventData Form data for the new event&#10; * @param coverImages Cover images for the event&#10; */&#10;export async function createEvent(eventData: CreateEventFormData, coverImages: File[]): Promise&lt;EventResponseDTO&gt; {&#10;    try {&#10;        const formData = new FormData();&#10;&#10;        // Convert the event data to a JSON string and add it as a part&#10;        formData.append('request', JSON.stringify(eventData));&#10;&#10;        // Add each cover image as a separate part&#10;        if (coverImages &amp;&amp; coverImages.length &gt; 0) {&#10;            coverImages.forEach((file) =&gt; {&#10;                formData.append('coverImages', file);&#10;            });&#10;        }&#10;&#10;        // Use apiFetch instead of raw fetch&#10;        return await apiFetch&lt;EventResponseDTO&gt;('/v1/events', {&#10;            method: 'POST',&#10;            body: formData,&#10;            // No need to set headers, apiFetch handles that&#10;        });&#10;    } catch (error) {&#10;        console.error('Error creating event:', error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Fetch event details by ID&#10; * @param eventId The ID of the event to fetch&#10; */&#10;export async function getEventById(eventId: string): Promise&lt;EventDetailDTO&gt; {&#10;    try {&#10;        return await apiFetch&lt;EventDetailDTO&gt;(`/v1/events/${eventId}`, {&#10;            method: 'GET',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error fetching event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Fetch all events (admin only)&#10; * @param status Optional filter for event status&#10; * @param page Page number (0-based)&#10; * @param size Number of events per page&#10; */&#10;export async function getAllEvents(&#10;    status?: EventStatus,&#10;    page: number = 0,&#10;    size: number = 10&#10;): Promise&lt;{ content: EventSummaryDTO[], totalPages: number, totalElements: number }&gt; {&#10;    try {&#10;        let url = `/v1/events?page=${page}&amp;size=${size}`;&#10;        if (status) {&#10;            url += `&amp;status=${status}`;&#10;        }&#10;&#10;        return await apiFetch&lt;{ content: EventSummaryDTO[], totalPages: number, totalElements: number }&gt;(url, {&#10;            method: 'GET',&#10;        });&#10;    } catch (error) {&#10;        console.error('Error fetching events:', error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Approve an event (admin only)&#10; * @param eventId The ID of the event to approve&#10; */&#10;export async function approveEvent(eventId: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`/v1/events/${eventId}/approve`, {&#10;            method: 'POST',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error approving event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Reject an event (admin only)&#10; * @param eventId The ID of the event to reject&#10; * @param reason The reason for rejecting the event&#10; */&#10;export async function rejectEvent(eventId: string, reason: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`/v1/events/${eventId}/reject`, {&#10;            method: 'POST',&#10;            body: JSON.stringify({reason}),&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error rejecting event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Delete an event&#10; * @param eventId The ID of the event to delete&#10; */&#10;export async function deleteEvent(eventId: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`/v1/events/${eventId}`, {&#10;            method: 'DELETE',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error deleting event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import {CreateEventFormData} from &quot;@/lib/validators/event&quot;;&#10;import {apiFetch} from '@/lib/api';&#10;&#10;/**&#10; * Type definitions based on the provided Java DTOs&#10; */&#10;&#10;export enum EventStatus {&#10;    PENDING = 'PENDING',&#10;    APPROVED = 'APPROVED',&#10;    REJECTED = 'REJECTED'&#10;}&#10;&#10;export interface EventResponseDTO {&#10;    id: string;&#10;    title: string;&#10;    status: string;&#10;    organizationId: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;}&#10;&#10;export interface EventSummaryDTO {&#10;    id: string;&#10;    title: string;&#10;    status: EventStatus;&#10;    organizationName: string;&#10;    organizationId: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;    description: string;&#10;    coverPhoto: string;&#10;    sessionCount: number;&#10;    earliestSessionDate: string;&#10;}&#10;&#10;export interface EventDetailDTO {&#10;    id: string;&#10;    title: string;&#10;    description: string;&#10;    overview: string;&#10;    status: EventStatus;&#10;    rejectionReason: string | null;&#10;    coverPhotos: string[];&#10;    organizationId: string;&#10;    organizationName: string;&#10;    categoryId: string;&#10;    categoryName: string;&#10;    createdAt: string;&#10;    updatedAt: string;&#10;    tiers: TierDTO[];&#10;    sessions: SessionDetailDTO[];&#10;}&#10;&#10;export interface TierDTO {&#10;    id: string;&#10;    name: string;&#10;    color: string;&#10;    price: number;&#10;}&#10;&#10;export interface VenueDetailsDTO {&#10;    address: string;&#10;    name: string;&#10;    latitude: number | null;&#10;    longitude: number | null;&#10;}&#10;&#10;export interface SessionSeatingMapDTO {&#10;    name: string | null;&#10;    layout: {&#10;        blocks: {&#10;            id: string;&#10;            name: string;&#10;            type: 'seated_grid' | 'standing_capacity' | 'non_sellable';&#10;            position: {&#10;                x: number;&#10;                y: number;&#10;            };&#10;            rows?: {&#10;                id: string;&#10;                label: string;&#10;                seats: {&#10;                    id: string;&#10;                    label: string;&#10;                    tierId?: string;&#10;                    status?: string;&#10;                }[];&#10;            }[];&#10;            capacity?: number | null;&#10;            width?: number | null;&#10;            height?: number | null;&#10;            seats?: {&#10;                id: string;&#10;                label: string;&#10;                tierId?: string;&#10;                status?: string;&#10;            }[];&#10;        }[];&#10;    };&#10;}&#10;&#10;export interface SessionDetailDTO {&#10;    id: string;&#10;    startTime: string;&#10;    endTime: string;&#10;    isOnline: boolean;&#10;    onlineLink: string | null;&#10;    venueDetails: VenueDetailsDTO | null;&#10;    salesStartRuleType: 'IMMEDIATE' | 'ROLLING' | 'FIXED';&#10;    salesStartHoursBefore: number | null;&#10;    salesStartFixedDatetime: string | null;&#10;    status: string;&#10;    layoutData: SessionSeatingMapDTO;&#10;}&#10;&#10;export interface RejectEventRequest {&#10;    reason: string;&#10;}&#10;&#10;const API_BASE_PATH = '/event-seating/v1/events';&#10;&#10;/**&#10; * Create a new event&#10; * @param eventData Form data for the new event&#10; * @param coverImages Cover images for the event&#10; */&#10;export async function createEvent(eventData: CreateEventFormData, coverImages: File[]): Promise&lt;EventResponseDTO&gt; {&#10;    try {&#10;        const formData = new FormData();&#10;&#10;        // Convert the event data to a JSON string and add it as a part&#10;        formData.append('request', JSON.stringify(eventData));&#10;&#10;        // Add each cover image as a separate part&#10;        if (coverImages &amp;&amp; coverImages.length &gt; 0) {&#10;            coverImages.forEach((file) =&gt; {&#10;                formData.append('coverImages', file);&#10;            });&#10;        }&#10;&#10;        // Use apiFetch instead of raw fetch&#10;        return await apiFetch&lt;EventResponseDTO&gt;(`${API_BASE_PATH}`, {&#10;            method: 'POST',&#10;            body: formData,&#10;            // No need to set headers, apiFetch handles that&#10;        });&#10;    } catch (error) {&#10;        console.error('Error creating event:', error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Fetch event details by ID&#10; * @param eventId The ID of the event to fetch&#10; */&#10;export async function getEventById(eventId: string): Promise&lt;EventDetailDTO&gt; {&#10;    try {&#10;        return await apiFetch&lt;EventDetailDTO&gt;(`${API_BASE_PATH}/${eventId}`, {&#10;            method: 'GET',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error fetching event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Fetch all events (admin only)&#10; * @param status Optional filter for event status&#10; * @param page Page number (0-based)&#10; * @param size Number of events per page&#10; */&#10;export async function getAllEvents(&#10;    status?: EventStatus,&#10;    page: number = 0,&#10;    size: number = 10&#10;): Promise&lt;{ content: EventSummaryDTO[], totalPages: number, totalElements: number }&gt; {&#10;    try {&#10;        let url = `${API_BASE_PATH}?page=${page}&amp;size=${size}`;&#10;        if (status) {&#10;            url += `&amp;status=${status}`;&#10;        }&#10;&#10;        return await apiFetch&lt;{ content: EventSummaryDTO[], totalPages: number, totalElements: number }&gt;(url, {&#10;            method: 'GET',&#10;        });&#10;    } catch (error) {&#10;        console.error('Error fetching events:', error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Approve an event (admin only)&#10; * @param eventId The ID of the event to approve&#10; */&#10;export async function approveEvent(eventId: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`${API_BASE_PATH}/${eventId}/approve`, {&#10;            method: 'POST',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error approving event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Reject an event (admin only)&#10; * @param eventId The ID of the event to reject&#10; * @param reason The reason for rejecting the event&#10; */&#10;export async function rejectEvent(eventId: string, reason: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`${API_BASE_PATH}/${eventId}/reject`, {&#10;            method: 'POST',&#10;            body: JSON.stringify({reason}),&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error rejecting event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;/**&#10; * Delete an event&#10; * @param eventId The ID of the event to delete&#10; */&#10;export async function deleteEvent(eventId: string): Promise&lt;void&gt; {&#10;    try {&#10;        await apiFetch&lt;void&gt;(`${API_BASE_PATH}/${eventId}`, {&#10;            method: 'DELETE',&#10;        });&#10;    } catch (error) {&#10;        console.error(`Error deleting event ${eventId}:`, error);&#10;        throw error;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/providers/LimitProvider.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/providers/LimitProvider.ts" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return (&#10;        &lt;LimitContext.Provider value={value}&gt;&#10;            {children}&#10;        &lt;/LimitContext.Provider&gt;&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return React.createElement(&#10;        LimitContext.Provider,&#10;        { value },&#10;        children&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>