<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/RecurringSessionsDialog.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/RecurringSessionsDialog.tsx" />
              <option name="originalContent" value="import {Controller, useForm} from &quot;react-hook-form&quot;;&#10;import {addDays, addWeeks, format, setHours, setMinutes} from &quot;date-fns&quot;;&#10;import {&#10;    Dialog,&#10;    DialogContent,&#10;    DialogDescription,&#10;    DialogFooter,&#10;    DialogHeader,&#10;    DialogTitle&#10;} from &quot;@/components/ui/dialog&quot;;&#10;import {FormControl, FormField, FormItem, FormLabel} from &quot;@/components/ui/form&quot;;&#10;import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue} from &quot;@/components/ui/select&quot;;&#10;import {Input} from &quot;@/components/ui/input&quot;;&#10;import {Popover, PopoverContent, PopoverTrigger} from &quot;@/components/ui/popover&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Calendar as CalendarIcon} from &quot;lucide-react&quot;;&#10;import {Calendar} from &quot;@/components/ui/calendar&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {SessionFormData} from &quot;@/lib/validators/event&quot;;&#10;import { Switch } from &quot;@/components/ui/switch&quot;;&#10;import { toast } from &quot;sonner&quot;;&#10;&#10;export function RecurringSessionsDialog({open, setOpen, onGenerate, currentSessionCount, maxSessions}: {&#10;    open: boolean,&#10;    setOpen: (open: boolean) =&gt; void,&#10;    onGenerate: (sessions: SessionFormData[]) =&gt; void,&#10;    currentSessionCount: number,&#10;    maxSessions: number&#10;}) {&#10;    const {control, handleSubmit, watch, setValue} = useForm({&#10;        defaultValues: {&#10;            frequency: 'weekly',&#10;            interval: 1,&#10;            count: 8,&#10;            startDate: new Date(),&#10;            startTime: '19:00',&#10;            durationHours: 2,&#10;            salesStartRuleType: 'ROLLING',&#10;            salesStartHoursBefore: 168,&#10;            salesStartFixedDatetime: new Date(),&#10;            isDaysNotHours: true, // New field to track if user is entering days or hours&#10;        }&#10;    });&#10;&#10;    const salesStartHoursBefore = watch('salesStartHoursBefore');&#10;    const isDaysNotHours = watch('isDaysNotHours');&#10;    const sessionCount = watch('count');&#10;&#10;    // Handle toggling between days and hours&#10;    const handleUnitToggle = (checked: boolean) =&gt; {&#10;        setValue('isDaysNotHours', checked);&#10;        if (checked) {&#10;            // Converting hours to days (rounded)&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24) * 24);&#10;        } else {&#10;            // Converting days to hours&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24));&#10;        }&#10;    };&#10;&#10;    const onSubmit = (data: any) =&gt; {&#10;        // Check if adding these sessions would exceed the limit&#10;        if (currentSessionCount + data.count &gt; maxSessions) {&#10;            toast.error(`Cannot add ${data.count} sessions. You are limited to ${maxSessions} total sessions (${currentSessionCount} already added).`);&#10;            return;&#10;        }&#10;&#10;        const newSessions = [];&#10;        let currentStartTime = setMinutes(setHours(data.startDate, parseInt(data.startTime.split(':')[0])), parseInt(data.startTime.split(':')[1]));&#10;&#10;        for (let i = 0; i &lt; data.count; i++) {&#10;            const endTime = new Date(currentStartTime.getTime() + data.durationHours * 60 * 60 * 1000);&#10;            newSessions.push({&#10;                startTime: currentStartTime.toISOString(),&#10;                endTime: endTime.toISOString(),&#10;                isOnline: false, // Default values&#10;                salesStartRuleType: data.salesStartRuleType,&#10;                salesStartHoursBefore: data.salesStartHoursBefore, // Always using hours for the API&#10;                salesStartFixedDatetime: data.salesStartFixedDatetime?.toISOString(),&#10;                layoutData: {name: 'Default', layout: {blocks: []}},&#10;            });&#10;&#10;            if (data.frequency === 'daily') {&#10;                currentStartTime = addDays(currentStartTime, data.interval);&#10;            } else if (data.frequency === 'weekly') {&#10;                currentStartTime = addWeeks(currentStartTime, data.interval);&#10;            }&#10;        }&#10;        onGenerate(newSessions);&#10;        setOpen(false);&#10;    };&#10;&#10;    return (&#10;        &lt;Dialog open={open} onOpenChange={setOpen}&gt;&#10;            &lt;DialogContent&gt;&#10;                &lt;DialogHeader&gt;&#10;                    &lt;DialogTitle&gt;Add Recurring Sessions&lt;/DialogTitle&gt;&#10;                    &lt;DialogDescription&gt;&#10;                        Generate a series of sessions based on a recurring pattern.&#10;                        {maxSessions &gt; 0 &amp;&amp; (&#10;                            &lt;span className=&quot;block mt-1 text-sm text-muted-foreground&quot;&gt;&#10;                                Limit: {currentSessionCount}/{maxSessions} sessions used.&#10;                            &lt;/span&gt;&#10;                        )}&#10;                    &lt;/DialogDescription&gt;&#10;                &lt;/DialogHeader&gt;&#10;                &lt;form onSubmit={handleSubmit(onSubmit)} className=&quot;space-y-4&quot;&gt;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;frequency&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Frequency&lt;/FormLabel&gt;&lt;Select onValueChange={field.onChange}&#10;                                                                              defaultValue={field.value}&gt;&lt;FormControl&gt;&lt;SelectTrigger&gt;&lt;SelectValue/&gt;&lt;/SelectTrigger&gt;&lt;/FormControl&gt;&lt;SelectContent&gt;&lt;SelectItem&#10;                                value=&quot;daily&quot;&gt;Daily&lt;/SelectItem&gt;&lt;SelectItem&#10;                                value=&quot;weekly&quot;&gt;Weekly&lt;/SelectItem&gt;&lt;/SelectContent&gt;&lt;/Select&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;interval&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Repeat Every&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot;&#10;                                                                                             min=&quot;1&quot; {...field}&#10;                                                                                             onChange={e =&gt; field.onChange(parseInt(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;Controller name=&quot;count&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&lt;FormLabel&gt;Number of Sessions&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot; min=&quot;1&quot;&#10;                                                                                               max=&quot;52&quot; {...field}&#10;                                                                                               onChange={e =&gt; field.onChange(parseInt(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                    )}/&gt;&#10;                    &lt;Controller name=&quot;startDate&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&lt;FormLabel&gt;Start Date&lt;/FormLabel&gt;&lt;Popover&gt;&lt;PopoverTrigger asChild&gt;&lt;Button&#10;                            variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&lt;CalendarIcon&#10;                            className=&quot;mr-2 h-4 w-4&quot;/&gt;{field.value ? format(field.value, 'PPP') :&#10;                            &lt;span&gt;Pick a date&lt;/span&gt;}&lt;/Button&gt;&lt;/PopoverTrigger&gt;&lt;PopoverContent&#10;                            className=&quot;w-auto p-0&quot;&gt;&lt;Calendar mode=&quot;single&quot; selected={field.value}&#10;                                                             onSelect={field.onChange}&#10;                                                             autoFocus/&gt;&lt;/PopoverContent&gt;&lt;/Popover&gt;&lt;/FormItem&gt;&#10;                    )}/&gt;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;startTime&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Start Time&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                type=&quot;time&quot; {...field}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;durationHours&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Duration (hours)&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot; min=&quot;0.5&quot;&#10;                                                                                                 step=&quot;0.5&quot; {...field}&#10;                                                                                                 onChange={e =&gt; field.onChange(parseFloat(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;salesStartRuleType&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Sales Start Rule&lt;/FormLabel&gt;&#10;                                &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;SelectTrigger&gt;&#10;                                            &lt;SelectValue/&gt;&#10;                                        &lt;/SelectTrigger&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;SelectContent&gt;&#10;                                        &lt;SelectItem value=&quot;IMMEDIATE&quot;&gt;Immediate&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;ROLLING&quot;&gt;Rolling (Before Event)&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;FIXED&quot;&gt;Fixed Datetime&lt;/SelectItem&gt;&#10;                                    &lt;/SelectContent&gt;&#10;                                &lt;/Select&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;&#10;&#10;                        {watch('salesStartRuleType') === 'ROLLING' &amp;&amp; (&#10;                            &lt;div className=&quot;space-y-2&quot;&gt;&#10;                                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                    &lt;FormLabel&gt;Unit&lt;/FormLabel&gt;&#10;                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Hours&lt;/span&gt;&#10;                                        &lt;Controller&#10;                                            name=&quot;isDaysNotHours&quot;&#10;                                            control={control}&#10;                                            render={({field}) =&gt; (&#10;                                                &lt;Switch&#10;                                                    checked={field.value}&#10;                                                    onCheckedChange={handleUnitToggle}&#10;                                                /&gt;&#10;                                            )}&#10;                                        /&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Days&lt;/span&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                &lt;Controller&#10;                                    name=&quot;salesStartHoursBefore&quot;&#10;                                    control={control}&#10;                                    render={({field}) =&gt; (&#10;                                        &lt;FormItem&gt;&#10;                                            &lt;FormLabel&gt;&#10;                                                {isDaysNotHours ? 'Days before event' : 'Hours before event'}&#10;                                            &lt;/FormLabel&gt;&#10;                                            &lt;FormControl&gt;&#10;                                                &lt;Input&#10;                                                    type=&quot;number&quot;&#10;                                                    min=&quot;1&quot;&#10;                                                    {...field}&#10;                                                    value={isDaysNotHours ? Math.round(field.value / 24) : field.value}&#10;                                                    onChange={(e) =&gt; {&#10;                                                        const value = parseInt(e.target.value);&#10;                                                        if (isDaysNotHours) {&#10;                                                            // If days, store as hours in the form data&#10;                                                            field.onChange(value * 24);&#10;                                                        } else {&#10;                                                            field.onChange(value);&#10;                                                        }&#10;                                                    }}&#10;                                                /&gt;&#10;                                            &lt;/FormControl&gt;&#10;                                        &lt;/FormItem&gt;&#10;                                    )}&#10;                                /&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;&#10;                        {watch('salesStartRuleType') === 'FIXED' &amp;&amp; (&#10;                            &lt;Controller name=&quot;salesStartFixedDatetime&quot; control={control} render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Sales Start Date&lt;/FormLabel&gt;&#10;                                    &lt;Popover&gt;&#10;                                        &lt;PopoverTrigger asChild&gt;&#10;                                            &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                                &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                                {field.value ? format(field.value, 'PPP p') :&#10;                                                    &lt;span&gt;Pick a datetime&lt;/span&gt;}&#10;                                            &lt;/Button&gt;&#10;                                        &lt;/PopoverTrigger&gt;&#10;                                        &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                            &lt;Calendar&#10;                                                mode=&quot;single&quot;&#10;                                                selected={field.value}&#10;                                                onSelect={field.onChange}&#10;                                                autoFocus&#10;                                            /&gt;&#10;                                        &lt;/PopoverContent&gt;&#10;                                    &lt;/Popover&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}/&gt;&#10;                        )}&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;DialogFooter&gt;&#10;                        &lt;Button type=&quot;submit&quot;&gt;Generate Sessions&lt;/Button&gt;&#10;                    &lt;/DialogFooter&gt;&#10;                &lt;/form&gt;&#10;            &lt;/DialogContent&gt;&#10;        &lt;/Dialog&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Controller, useForm} from &quot;react-hook-form&quot;;&#10;import {addDays, addWeeks, format, setHours, setMinutes} from &quot;date-fns&quot;;&#10;import {&#10;    Dialog,&#10;    DialogContent,&#10;    DialogDescription,&#10;    DialogFooter,&#10;    DialogHeader,&#10;    DialogTitle&#10;} from &quot;@/components/ui/dialog&quot;;&#10;import {FormControl, FormField, FormItem, FormLabel} from &quot;@/components/ui/form&quot;;&#10;import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue} from &quot;@/components/ui/select&quot;;&#10;import {Input} from &quot;@/components/ui/input&quot;;&#10;import {Popover, PopoverContent, PopoverTrigger} from &quot;@/components/ui/popover&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Calendar as CalendarIcon} from &quot;lucide-react&quot;;&#10;import {Calendar} from &quot;@/components/ui/calendar&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {SalesStartRuleType, SessionFormData} from &quot;@/lib/validators/event&quot;;&#10;import { Switch } from &quot;@/components/ui/switch&quot;;&#10;import { toast } from &quot;sonner&quot;;&#10;&#10;interface RecurringSessionFormValues {&#10;    frequency: 'daily' | 'weekly';&#10;    interval: number;&#10;    count: number;&#10;    startDate: Date;&#10;    startTime: string;&#10;    durationHours: number;&#10;    salesStartRuleType: SalesStartRuleType;&#10;    salesStartHoursBefore: number;&#10;    salesStartFixedDatetime: Date;&#10;    isDaysNotHours: boolean;&#10;}&#10;&#10;export function RecurringSessionsDialog({open, setOpen, onGenerate, currentSessionCount, maxSessions}: {&#10;    open: boolean,&#10;    setOpen: (open: boolean) =&gt; void,&#10;    onGenerate: (sessions: SessionFormData[]) =&gt; void,&#10;    currentSessionCount: number,&#10;    maxSessions: number&#10;}) {&#10;    const {control, handleSubmit, watch, setValue} = useForm&lt;RecurringSessionFormValues&gt;({&#10;        defaultValues: {&#10;            frequency: 'weekly',&#10;            interval: 1,&#10;            count: 8,&#10;            startDate: new Date(),&#10;            startTime: '19:00',&#10;            durationHours: 2,&#10;            salesStartRuleType: SalesStartRuleType.ROLLING,&#10;            salesStartHoursBefore: 168,&#10;            salesStartFixedDatetime: new Date(),&#10;            isDaysNotHours: true,&#10;        }&#10;    });&#10;    &#10;    const salesStartHoursBefore = watch('salesStartHoursBefore');&#10;    const isDaysNotHours = watch('isDaysNotHours');&#10;    const sessionCount = watch('count');&#10;    &#10;    // Handle toggling between days and hours&#10;    const handleUnitToggle = (checked: boolean) =&gt; {&#10;        setValue('isDaysNotHours', checked);&#10;        if (checked) {&#10;            // Converting hours to days (rounded)&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24) * 24);&#10;        } else {&#10;            // Converting days to hours&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24));&#10;        }&#10;    };&#10;&#10;    const onSubmit = (data: RecurringSessionFormValues) =&gt; {&#10;        // Check if adding these sessions would exceed the limit&#10;        if (currentSessionCount + data.count &gt; maxSessions) {&#10;            toast.error(`Cannot add ${data.count} sessions. You are limited to ${maxSessions} total sessions (${currentSessionCount} already added).`);&#10;            return;&#10;        }&#10;        &#10;        const newSessions: SessionFormData[] = [];&#10;        let currentStartTime = setMinutes(&#10;            setHours(data.startDate, parseInt(data.startTime.split(':')[0])), &#10;            parseInt(data.startTime.split(':')[1])&#10;        );&#10;&#10;        for (let i = 0; i &lt; data.count; i++) {&#10;            const endTime = new Date(currentStartTime.getTime() + data.durationHours * 60 * 60 * 1000);&#10;            newSessions.push({&#10;                startTime: currentStartTime.toISOString(),&#10;                endTime: endTime.toISOString(),&#10;                isOnline: false,&#10;                salesStartRuleType: data.salesStartRuleType,&#10;                salesStartHoursBefore: data.salesStartHoursBefore,&#10;                salesStartFixedDatetime: data.salesStartFixedDatetime?.toISOString(),&#10;                layoutData: {name: 'Default', layout: {blocks: []}},&#10;            });&#10;&#10;            if (data.frequency === 'daily') {&#10;                currentStartTime = addDays(currentStartTime, data.interval);&#10;            } else if (data.frequency === 'weekly') {&#10;                currentStartTime = addWeeks(currentStartTime, data.interval);&#10;            }&#10;        }&#10;        onGenerate(newSessions);&#10;        setOpen(false);&#10;    };&#10;&#10;    return (&#10;        &lt;Dialog open={open} onOpenChange={setOpen}&gt;&#10;            &lt;DialogContent&gt;&#10;                &lt;DialogHeader&gt;&#10;                    &lt;DialogTitle&gt;Add Recurring Sessions&lt;/DialogTitle&gt;&#10;                    &lt;DialogDescription&gt;&#10;                        Generate a series of sessions based on a recurring pattern.&#10;                        {maxSessions &gt; 0 &amp;&amp; (&#10;                            &lt;span className=&quot;block mt-1 text-sm text-muted-foreground&quot;&gt;&#10;                                Limit: {currentSessionCount}/{maxSessions} sessions used.&#10;                            &lt;/span&gt;&#10;                        )}&#10;                    &lt;/DialogDescription&gt;&#10;                &lt;/DialogHeader&gt;&#10;                &lt;form onSubmit={handleSubmit(onSubmit)} className=&quot;space-y-4&quot;&gt;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;frequency&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Frequency&lt;/FormLabel&gt;&lt;Select onValueChange={field.onChange}&#10;                                                                              defaultValue={field.value}&gt;&lt;FormControl&gt;&lt;SelectTrigger&gt;&lt;SelectValue/&gt;&lt;/SelectTrigger&gt;&lt;/FormControl&gt;&lt;SelectContent&gt;&lt;SelectItem&#10;                                value=&quot;daily&quot;&gt;Daily&lt;/SelectItem&gt;&lt;SelectItem&#10;                                value=&quot;weekly&quot;&gt;Weekly&lt;/SelectItem&gt;&lt;/SelectContent&gt;&lt;/Select&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;interval&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Repeat Every&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot;&#10;                                                                                             min=&quot;1&quot; {...field}&#10;                                                                                             onChange={e =&gt; field.onChange(parseInt(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;Controller name=&quot;count&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&lt;FormLabel&gt;Number of Sessions&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot; min=&quot;1&quot;&#10;                                                                                               max=&quot;52&quot; {...field}&#10;                                                                                               onChange={e =&gt; field.onChange(parseInt(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                    )}/&gt;&#10;                    &lt;Controller name=&quot;startDate&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&lt;FormLabel&gt;Start Date&lt;/FormLabel&gt;&lt;Popover&gt;&lt;PopoverTrigger asChild&gt;&lt;Button&#10;                            variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&lt;CalendarIcon&#10;                            className=&quot;mr-2 h-4 w-4&quot;/&gt;{field.value ? format(field.value, 'PPP') :&#10;                            &lt;span&gt;Pick a date&lt;/span&gt;}&lt;/Button&gt;&lt;/PopoverTrigger&gt;&lt;PopoverContent&#10;                            className=&quot;w-auto p-0&quot;&gt;&lt;Calendar mode=&quot;single&quot; selected={field.value}&#10;                                                             onSelect={field.onChange}&#10;                                                             autoFocus/&gt;&lt;/PopoverContent&gt;&lt;/Popover&gt;&lt;/FormItem&gt;&#10;                    )}/&gt;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;startTime&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Start Time&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                type=&quot;time&quot; {...field}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;durationHours&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Duration (hours)&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input type=&quot;number&quot; min=&quot;0.5&quot;&#10;                                                                                                 step=&quot;0.5&quot; {...field}&#10;                                                                                                 onChange={e =&gt; field.onChange(parseFloat(e.target.value))}/&gt;&lt;/FormControl&gt;&lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;salesStartRuleType&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Sales Start Rule&lt;/FormLabel&gt;&#10;                                &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;SelectTrigger&gt;&#10;                                            &lt;SelectValue/&gt;&#10;                                        &lt;/SelectTrigger&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;SelectContent&gt;&#10;                                        &lt;SelectItem value=&quot;IMMEDIATE&quot;&gt;Immediate&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;ROLLING&quot;&gt;Rolling (Before Event)&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;FIXED&quot;&gt;Fixed Datetime&lt;/SelectItem&gt;&#10;                                    &lt;/SelectContent&gt;&#10;                                &lt;/Select&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;&#10;&#10;                        {watch('salesStartRuleType') === 'ROLLING' &amp;&amp; (&#10;                            &lt;div className=&quot;space-y-2&quot;&gt;&#10;                                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                    &lt;FormLabel&gt;Unit&lt;/FormLabel&gt;&#10;                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Hours&lt;/span&gt;&#10;                                        &lt;Controller&#10;                                            name=&quot;isDaysNotHours&quot;&#10;                                            control={control}&#10;                                            render={({field}) =&gt; (&#10;                                                &lt;Switch&#10;                                                    checked={field.value}&#10;                                                    onCheckedChange={handleUnitToggle}&#10;                                                /&gt;&#10;                                            )}&#10;                                        /&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Days&lt;/span&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                &lt;Controller&#10;                                    name=&quot;salesStartHoursBefore&quot;&#10;                                    control={control}&#10;                                    render={({field}) =&gt; (&#10;                                        &lt;FormItem&gt;&#10;                                            &lt;FormLabel&gt;&#10;                                                {isDaysNotHours ? 'Days before event' : 'Hours before event'}&#10;                                            &lt;/FormLabel&gt;&#10;                                            &lt;FormControl&gt;&#10;                                                &lt;Input&#10;                                                    type=&quot;number&quot;&#10;                                                    min=&quot;1&quot;&#10;                                                    {...field}&#10;                                                    value={isDaysNotHours ? Math.round(field.value / 24) : field.value}&#10;                                                    onChange={(e) =&gt; {&#10;                                                        const value = parseInt(e.target.value);&#10;                                                        if (isDaysNotHours) {&#10;                                                            // If days, store as hours in the form data&#10;                                                            field.onChange(value * 24);&#10;                                                        } else {&#10;                                                            field.onChange(value);&#10;                                                        }&#10;                                                    }}&#10;                                                /&gt;&#10;                                            &lt;/FormControl&gt;&#10;                                        &lt;/FormItem&gt;&#10;                                    )}&#10;                                /&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;&#10;                        {watch('salesStartRuleType') === 'FIXED' &amp;&amp; (&#10;                            &lt;Controller name=&quot;salesStartFixedDatetime&quot; control={control} render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Sales Start Date&lt;/FormLabel&gt;&#10;                                    &lt;Popover&gt;&#10;                                        &lt;PopoverTrigger asChild&gt;&#10;                                            &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                                &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                                {field.value ? format(field.value, 'PPP p') :&#10;                                                    &lt;span&gt;Pick a datetime&lt;/span&gt;}&#10;                                            &lt;/Button&gt;&#10;                                        &lt;/PopoverTrigger&gt;&#10;                                        &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                            &lt;Calendar&#10;                                                mode=&quot;single&quot;&#10;                                                selected={field.value}&#10;                                                onSelect={field.onChange}&#10;                                                autoFocus&#10;                                            /&gt;&#10;                                        &lt;/PopoverContent&gt;&#10;                                    &lt;/Popover&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}/&gt;&#10;                        )}&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;DialogFooter&gt;&#10;                        &lt;Button type=&quot;submit&quot;&gt;Generate Sessions&lt;/Button&gt;&#10;                    &lt;/DialogFooter&gt;&#10;                &lt;/form&gt;&#10;            &lt;/DialogContent&gt;&#10;        &lt;/Dialog&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SchedulingStep.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SchedulingStep.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState} from 'react';&#10;import {useFieldArray, useFormContext} from 'react-hook-form';&#10;import {CreateEventFormData, SessionFormData} from '@/lib/validators/event';&#10;import {Button} from '@/components/ui/button';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {PlusCircle, Repeat, Trash2,} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import {SessionConfigDialog} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionConfigDialog&quot;;&#10;import {&#10;    RecurringSessionsDialog&#10;} from &quot;@/app/manage/organization/[organization_id]/event/_components/RecurringSessionsDialog&quot;;&#10;import {SingleSessionDialog} from &quot;@/app/manage/organization/[organization_id]/event/_components/SingleSessionDialog&quot;;&#10;import {SessionListItem} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionListItem&quot;;&#10;import {useLimits} from &quot;@/providers/LimitProvider&quot;;&#10;&#10;// --- Main Scheduling Step Component ---&#10;export function SchedulingStep() {&#10;    const {control, formState: {errors}} = useFormContext&lt;CreateEventFormData&gt;();&#10;    const [configuringIndex, setConfiguringIndex] = useState&lt;number | null&gt;(null);&#10;    const [isRecurringDialogOpen, setIsRecurringDialogOpen] = useState(false);&#10;    const [isSingleSessionDialogOpen, setIsSingleSessionDialogOpen] = useState(false);&#10;    const {myLimits} = useLimits();&#10;&#10;    const maxSessions = myLimits?.tierLimits.maxSessionsPerEvent || 10; // Default to 10 if not set&#10;&#10;    const {fields, append, remove, replace} = useFieldArray({&#10;        control,&#10;        name: &quot;sessions&quot;,&#10;    });&#10;&#10;    const handleGenerateSessions = (newSessions: SessionFormData[]) =&gt; {&#10;        append(newSessions);&#10;        toast.success(`${newSessions.length} recurring sessions have been added.`);&#10;    };&#10;&#10;    const handleAddSingleSession = (newSession: SessionFormData) =&gt; {&#10;        append(newSession);&#10;        toast.success(&quot;New session has been added.&quot;);&#10;    };&#10;&#10;    const clearAllSessions = () =&gt; {&#10;        replace([]); // replace with an empty array&#10;        toast.info(&quot;All sessions have been cleared.&quot;);&#10;    };&#10;&#10;    return (&#10;        &lt;Card&gt;&#10;            &lt;CardHeader&gt;&#10;                &lt;CardTitle&gt;Scheduling &amp; Location&lt;/CardTitle&gt;&#10;                &lt;CardDescription&gt;&#10;                    Add the dates and times for your event. Each session can have a unique location.&#10;                &lt;/CardDescription&gt;&#10;            &lt;/CardHeader&gt;&#10;            &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;SessionListItem key={field.id} field={field} index={index} onRemove={remove}/&gt;&#10;                ))}&#10;&#10;                &lt;div className=&quot;flex flex-wrap gap-2 pt-4 border-t&quot;&gt;&#10;                    &lt;Button&#10;                        type=&quot;button&quot;&#10;                        variant=&quot;outline&quot;&#10;                        onClick={() =&gt; setIsSingleSessionDialogOpen(true)}&#10;                    &gt;&#10;                        &lt;PlusCircle className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                        Add Single Session&#10;                    &lt;/Button&gt;&#10;                    &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={() =&gt; setIsRecurringDialogOpen(true)}&gt;&#10;                        &lt;Repeat className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                        Add Recurring Sessions&#10;                    &lt;/Button&gt;&#10;                    {fields.length &gt; 0 &amp;&amp; (&#10;                        &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; className=&quot;ml-auto&quot; onClick={clearAllSessions}&gt;&#10;                            &lt;Trash2 className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                            Clear All&#10;                        &lt;/Button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {errors.sessions?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.sessions.root.message}&lt;/p&gt;&#10;                )}&#10;&#10;                {configuringIndex !== null &amp;&amp; (&#10;                    &lt;SessionConfigDialog&#10;                        index={configuringIndex}&#10;                        open={true}&#10;                        setOpen={() =&gt; setConfiguringIndex(null)}&#10;                    /&gt;&#10;                )}&#10;&#10;                &lt;RecurringSessionsDialog&#10;                    open={isRecurringDialogOpen}&#10;                    setOpen={setIsRecurringDialogOpen}&#10;                    onGenerate={handleGenerateSessions}&#10;                /&gt;&#10;&#10;                &lt;SingleSessionDialog&#10;                    open={isSingleSessionDialogOpen}&#10;                    setOpen={setIsSingleSessionDialogOpen}&#10;                    onAdd={handleAddSingleSession}&#10;                /&gt;&#10;            &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState} from 'react';&#10;import {useFieldArray, useFormContext} from 'react-hook-form';&#10;import {CreateEventFormData, SessionFormData} from '@/lib/validators/event';&#10;import {Button} from '@/components/ui/button';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {PlusCircle, Repeat, Trash2,} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import {SessionConfigDialog} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionConfigDialog&quot;;&#10;import {&#10;    RecurringSessionsDialog&#10;} from &quot;@/app/manage/organization/[organization_id]/event/_components/RecurringSessionsDialog&quot;;&#10;import {SingleSessionDialog} from &quot;@/app/manage/organization/[organization_id]/event/_components/SingleSessionDialog&quot;;&#10;import {SessionListItem} from &quot;@/app/manage/organization/[organization_id]/event/_components/SessionListItem&quot;;&#10;import {useLimits} from &quot;@/providers/LimitProvider&quot;;&#10;&#10;// --- Main Scheduling Step Component ---&#10;export function SchedulingStep() {&#10;    const {control, formState: {errors}} = useFormContext&lt;CreateEventFormData&gt;();&#10;    const [configuringIndex, setConfiguringIndex] = useState&lt;number | null&gt;(null);&#10;    const [isRecurringDialogOpen, setIsRecurringDialogOpen] = useState(false);&#10;    const [isSingleSessionDialogOpen, setIsSingleSessionDialogOpen] = useState(false);&#10;    const {myLimits} = useLimits();&#10;&#10;    const maxSessions = myLimits?.tierLimits.maxSessionsPerEvent || 10; // Default to 10 if not set&#10;&#10;    const {fields, append, remove, replace} = useFieldArray({&#10;        control,&#10;        name: &quot;sessions&quot;,&#10;    });&#10;&#10;    const handleGenerateSessions = (newSessions: SessionFormData[]) =&gt; {&#10;        // Session count validation is now handled in the dialog component&#10;        append(newSessions);&#10;        toast.success(`${newSessions.length} recurring sessions have been added.`);&#10;    };&#10;&#10;    const handleAddSingleSession = (newSession: SessionFormData) =&gt; {&#10;        // Session count validation is now handled in the dialog component&#10;        append(newSession);&#10;        toast.success(&quot;New session has been added.&quot;);&#10;    };&#10;&#10;    const clearAllSessions = () =&gt; {&#10;        replace([]); // replace with an empty array&#10;        toast.info(&quot;All sessions have been cleared.&quot;);&#10;    };&#10;    &#10;    // Disable add buttons if we've reached the maximum&#10;    const hasReachedLimit = fields.length &gt;= maxSessions;&#10;    &#10;    const openSingleSessionDialog = () =&gt; {&#10;        if (hasReachedLimit) {&#10;            toast.error(`Cannot add more sessions. You have reached the limit of ${maxSessions} sessions.`);&#10;            return;&#10;        }&#10;        setIsSingleSessionDialogOpen(true);&#10;    };&#10;    &#10;    const openRecurringSessionsDialog = () =&gt; {&#10;        if (hasReachedLimit) {&#10;            toast.error(`Cannot add more sessions. You have reached the limit of ${maxSessions} sessions.`);&#10;            return;&#10;        }&#10;        setIsRecurringDialogOpen(true);&#10;    };&#10;&#10;    return (&#10;        &lt;Card&gt;&#10;            &lt;CardHeader&gt;&#10;                &lt;CardTitle&gt;Scheduling &amp; Location&lt;/CardTitle&gt;&#10;                &lt;CardDescription&gt;&#10;                    Add the dates and times for your event. Each session can have a unique location.&#10;                    {maxSessions &gt; 0 &amp;&amp; (&#10;                        &lt;span className=&quot;block mt-1&quot;&gt;&#10;                            Session limit: {fields.length}/{maxSessions}&#10;                        &lt;/span&gt;&#10;                    )}&#10;                &lt;/CardDescription&gt;&#10;            &lt;/CardHeader&gt;&#10;            &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;SessionListItem key={field.id} field={field} index={index} onRemove={remove}/&gt;&#10;                ))}&#10;&#10;                &lt;div className=&quot;flex flex-wrap gap-2 pt-4 border-t&quot;&gt;&#10;                    &lt;Button&#10;                        type=&quot;button&quot;&#10;                        variant=&quot;outline&quot;&#10;                        onClick={openSingleSessionDialog}&#10;                        disabled={hasReachedLimit}&#10;                    &gt;&#10;                        &lt;PlusCircle className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                        Add Single Session&#10;                    &lt;/Button&gt;&#10;                    &lt;Button &#10;                        type=&quot;button&quot; &#10;                        variant=&quot;outline&quot; &#10;                        onClick={openRecurringSessionsDialog}&#10;                        disabled={hasReachedLimit}&#10;                    &gt;&#10;                        &lt;Repeat className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                        Add Recurring Sessions&#10;                    &lt;/Button&gt;&#10;                    {fields.length &gt; 0 &amp;&amp; (&#10;                        &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; className=&quot;ml-auto&quot; onClick={clearAllSessions}&gt;&#10;                            &lt;Trash2 className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                            Clear All&#10;                        &lt;/Button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {errors.sessions?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.sessions.root.message}&lt;/p&gt;&#10;                )}&#10;&#10;                {configuringIndex !== null &amp;&amp; (&#10;                    &lt;SessionConfigDialog&#10;                        index={configuringIndex}&#10;                        open={true}&#10;                        setOpen={() =&gt; setConfiguringIndex(null)}&#10;                    /&gt;&#10;                )}&#10;&#10;                &lt;RecurringSessionsDialog&#10;                    open={isRecurringDialogOpen}&#10;                    setOpen={setIsRecurringDialogOpen}&#10;                    onGenerate={handleGenerateSessions}&#10;                    currentSessionCount={fields.length}&#10;                    maxSessions={maxSessions}&#10;                /&gt;&#10;&#10;                &lt;SingleSessionDialog&#10;                    open={isSingleSessionDialogOpen}&#10;                    setOpen={setIsSingleSessionDialogOpen}&#10;                    onAdd={handleAddSingleSession}&#10;                    currentSessionCount={fields.length}&#10;                    maxSessions={maxSessions}&#10;                /&gt;&#10;            &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SingleSessionDialog.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/SingleSessionDialog.tsx" />
              <option name="originalContent" value="import {Controller, useForm} from &quot;react-hook-form&quot;;&#10;import {format, setHours, setMinutes} from &quot;date-fns&quot;;&#10;import {&#10;    Dialog,&#10;    DialogContent,&#10;    DialogDescription,&#10;    DialogFooter,&#10;    DialogHeader,&#10;    DialogTitle&#10;} from &quot;@/components/ui/dialog&quot;;&#10;import {FormControl, FormItem, FormLabel} from &quot;@/components/ui/form&quot;;&#10;import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue} from &quot;@/components/ui/select&quot;;&#10;import {Input} from &quot;@/components/ui/input&quot;;&#10;import {Popover, PopoverContent, PopoverTrigger} from &quot;@/components/ui/popover&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Calendar as CalendarIcon} from &quot;lucide-react&quot;;&#10;import {Calendar} from &quot;@/components/ui/calendar&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {SessionFormData} from &quot;@/lib/validators/event&quot;;&#10;import {Switch} from &quot;@/components/ui/switch&quot;;&#10;import {SalesStartRuleType} from &quot;@/lib/validators/event&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;&#10;export function SingleSessionDialog({open, setOpen, onAdd, currentSessionCount, maxSessions}: {&#10;    open: boolean,&#10;    setOpen: (open: boolean) =&gt; void,&#10;    onAdd: (session: SessionFormData) =&gt; void,&#10;    currentSessionCount: number,&#10;    maxSessions: number&#10;}) {&#10;    const {control, handleSubmit, watch, setValue} = useForm({&#10;        defaultValues: {&#10;            startDate: new Date(),&#10;            startTime: '19:00',&#10;            durationHours: 2,&#10;            salesStartRuleType: 'ROLLING',&#10;            salesStartHoursBefore: 168,&#10;            salesStartFixedDatetime: new Date(),&#10;            isDaysNotHours: true, // Field to track if user is entering days or hours&#10;        }&#10;    });&#10;&#10;    const salesStartHoursBefore = watch('salesStartHoursBefore');&#10;    const isDaysNotHours = watch('isDaysNotHours');&#10;&#10;    // Handle toggling between days and hours&#10;    const handleUnitToggle = (checked: boolean) =&gt; {&#10;        setValue('isDaysNotHours', checked);&#10;        if (checked) {&#10;            // Converting hours to days (rounded)&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24) * 24);&#10;        } else {&#10;            // Converting days to hours&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24));&#10;        }&#10;    };&#10;&#10;    const onSubmit = (data: any) =&gt; {&#10;        // Check if adding this session would exceed the limit&#10;        if (currentSessionCount &gt;= maxSessions) {&#10;            toast.error(`Cannot add more sessions. You have reached the limit of ${maxSessions} sessions.`);&#10;            return;&#10;        }&#10;&#10;        // Create the session start time by combining date and time&#10;        const startTime = setMinutes(&#10;            setHours(&#10;                data.startDate,&#10;                parseInt(data.startTime.split(':')[0])&#10;            ),&#10;            parseInt(data.startTime.split(':')[1])&#10;        );&#10;&#10;        // Calculate end time based on duration&#10;        const endTime = new Date(startTime.getTime() + data.durationHours * 60 * 60 * 1000);&#10;&#10;        // Create the session object&#10;        const newSession: SessionFormData = {&#10;            startTime: startTime.toISOString(),&#10;            endTime: endTime.toISOString(),&#10;            isOnline: false,&#10;            salesStartRuleType: data.salesStartRuleType as SalesStartRuleType,&#10;            ...(data.salesStartRuleType === 'ROLLING' &amp;&amp; {&#10;                salesStartHoursBefore: data.salesStartHoursBefore,&#10;            }),&#10;            ...(data.salesStartRuleType === 'FIXED' &amp;&amp; {&#10;                salesStartFixedDatetime: data.salesStartFixedDatetime.toISOString(),&#10;            }),&#10;            layoutData: {name: 'Default', layout: {blocks: []}}&#10;        };&#10;&#10;        onAdd(newSession);&#10;        setOpen(false);&#10;    };&#10;&#10;    return (&#10;        &lt;Dialog open={open} onOpenChange={setOpen}&gt;&#10;            &lt;DialogContent&gt;&#10;                &lt;DialogHeader&gt;&#10;                    &lt;DialogTitle&gt;Add Single Session&lt;/DialogTitle&gt;&#10;                    &lt;DialogDescription&gt;&#10;                        Configure the details for this session.&#10;                        {maxSessions &gt; 0 &amp;&amp; (&#10;                            &lt;span className=&quot;block mt-1 text-sm text-muted-foreground&quot;&gt;&#10;                                Limit: {currentSessionCount}/{maxSessions} sessions used.&#10;                            &lt;/span&gt;&#10;                        )}&#10;                    &lt;/DialogDescription&gt;&#10;                &lt;/DialogHeader&gt;&#10;                &lt;form onSubmit={handleSubmit(onSubmit)} className=&quot;space-y-4&quot;&gt;&#10;                    &lt;Controller name=&quot;startDate&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&#10;                            &lt;FormLabel&gt;Date&lt;/FormLabel&gt;&#10;                            &lt;Popover&gt;&#10;                                &lt;PopoverTrigger asChild&gt;&#10;                                    &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                        &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                        {field.value ? format(field.value, 'PPP') : &lt;span&gt;Pick a date&lt;/span&gt;}&#10;                                    &lt;/Button&gt;&#10;                                &lt;/PopoverTrigger&gt;&#10;                                &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                    &lt;Calendar&#10;                                        mode=&quot;single&quot;&#10;                                        selected={field.value}&#10;                                        onSelect={field.onChange}&#10;                                        autoFocus&#10;                                    /&gt;&#10;                                &lt;/PopoverContent&gt;&#10;                            &lt;/Popover&gt;&#10;                        &lt;/FormItem&gt;&#10;                    )}/&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;startTime&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Start Time&lt;/FormLabel&gt;&#10;                                &lt;FormControl&gt;&#10;                                    &lt;Input type=&quot;time&quot; {...field}/&gt;&#10;                                &lt;/FormControl&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;durationHours&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Duration (hours)&lt;/FormLabel&gt;&#10;                                &lt;FormControl&gt;&#10;                                    &lt;Input&#10;                                        type=&quot;number&quot;&#10;                                        min=&quot;0.5&quot;&#10;                                        step=&quot;0.5&quot;&#10;                                        {...field}&#10;                                        onChange={e =&gt; field.onChange(parseFloat(e.target.value))}&#10;                                    /&gt;&#10;                                &lt;/FormControl&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;salesStartRuleType&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Sales Start Rule&lt;/FormLabel&gt;&#10;                                &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;SelectTrigger&gt;&#10;                                            &lt;SelectValue/&gt;&#10;                                        &lt;/SelectTrigger&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;SelectContent&gt;&#10;                                        &lt;SelectItem value=&quot;IMMEDIATE&quot;&gt;Immediate&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;ROLLING&quot;&gt;Rolling (Before Event)&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;FIXED&quot;&gt;Fixed Datetime&lt;/SelectItem&gt;&#10;                                    &lt;/SelectContent&gt;&#10;                                &lt;/Select&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;&#10;                        {watch('salesStartRuleType') === 'ROLLING' &amp;&amp; (&#10;                            &lt;div className=&quot;space-y-2&quot;&gt;&#10;                                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                    &lt;FormLabel&gt;Unit&lt;/FormLabel&gt;&#10;                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Hours&lt;/span&gt;&#10;                                        &lt;Controller&#10;                                            name=&quot;isDaysNotHours&quot;&#10;                                            control={control}&#10;                                            render={({field}) =&gt; (&#10;                                                &lt;Switch&#10;                                                    checked={field.value}&#10;                                                    onCheckedChange={handleUnitToggle}&#10;                                                /&gt;&#10;                                            )}&#10;                                        /&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Days&lt;/span&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                &lt;Controller&#10;                                    name=&quot;salesStartHoursBefore&quot;&#10;                                    control={control}&#10;                                    render={({field}) =&gt; (&#10;                                        &lt;FormItem&gt;&#10;                                            &lt;FormLabel&gt;&#10;                                                {isDaysNotHours ? 'Days before event' : 'Hours before event'}&#10;                                            &lt;/FormLabel&gt;&#10;                                            &lt;FormControl&gt;&#10;                                                &lt;Input&#10;                                                    type=&quot;number&quot;&#10;                                                    min=&quot;1&quot;&#10;                                                    {...field}&#10;                                                    value={isDaysNotHours ? Math.round(field.value / 24) : field.value}&#10;                                                    onChange={(e) =&gt; {&#10;                                                        const value = parseInt(e.target.value);&#10;                                                        if (isDaysNotHours) {&#10;                                                            // If days, store as hours in the form data&#10;                                                            field.onChange(value * 24);&#10;                                                        } else {&#10;                                                            field.onChange(value);&#10;                                                        }&#10;                                                    }}&#10;                                                /&gt;&#10;                                            &lt;/FormControl&gt;&#10;                                        &lt;/FormItem&gt;&#10;                                    )}&#10;                                /&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;&#10;                        {watch('salesStartRuleType') === 'FIXED' &amp;&amp; (&#10;                            &lt;Controller name=&quot;salesStartFixedDatetime&quot; control={control} render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Sales Start Date&lt;/FormLabel&gt;&#10;                                    &lt;Popover&gt;&#10;                                        &lt;PopoverTrigger asChild&gt;&#10;                                            &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                                &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                                {field.value ? format(field.value, 'PPP p') : &lt;span&gt;Pick a datetime&lt;/span&gt;}&#10;                                            &lt;/Button&gt;&#10;                                        &lt;/PopoverTrigger&gt;&#10;                                        &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                            &lt;Calendar&#10;                                                mode=&quot;single&quot;&#10;                                                selected={field.value}&#10;                                                onSelect={field.onChange}&#10;                                                autoFocus&#10;                                            /&gt;&#10;                                        &lt;/PopoverContent&gt;&#10;                                    &lt;/Popover&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}/&gt;&#10;                        )}&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;DialogFooter&gt;&#10;                        &lt;Button type=&quot;submit&quot;&gt;Add Session&lt;/Button&gt;&#10;                    &lt;/DialogFooter&gt;&#10;                &lt;/form&gt;&#10;            &lt;/DialogContent&gt;&#10;        &lt;/Dialog&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import {Controller, useForm} from &quot;react-hook-form&quot;;&#10;import {format, setHours, setMinutes} from &quot;date-fns&quot;;&#10;import {&#10;    Dialog,&#10;    DialogContent,&#10;    DialogDescription,&#10;    DialogFooter,&#10;    DialogHeader,&#10;    DialogTitle&#10;} from &quot;@/components/ui/dialog&quot;;&#10;import {FormControl, FormItem, FormLabel} from &quot;@/components/ui/form&quot;;&#10;import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue} from &quot;@/components/ui/select&quot;;&#10;import {Input} from &quot;@/components/ui/input&quot;;&#10;import {Popover, PopoverContent, PopoverTrigger} from &quot;@/components/ui/popover&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {Calendar as CalendarIcon} from &quot;lucide-react&quot;;&#10;import {Calendar} from &quot;@/components/ui/calendar&quot;;&#10;import * as React from &quot;react&quot;;&#10;import {SalesStartRuleType, SessionFormData} from &quot;@/lib/validators/event&quot;;&#10;import {Switch} from &quot;@/components/ui/switch&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;&#10;interface SingleSessionFormValues {&#10;    startDate: Date;&#10;    startTime: string;&#10;    durationHours: number;&#10;    salesStartRuleType: SalesStartRuleType;&#10;    salesStartHoursBefore: number;&#10;    salesStartFixedDatetime: Date;&#10;    isDaysNotHours: boolean;&#10;}&#10;&#10;export function SingleSessionDialog({open, setOpen, onAdd, currentSessionCount, maxSessions}: {&#10;    open: boolean,&#10;    setOpen: (open: boolean) =&gt; void,&#10;    onAdd: (session: SessionFormData) =&gt; void,&#10;    currentSessionCount: number,&#10;    maxSessions: number&#10;}) {&#10;    const {control, handleSubmit, watch, setValue} = useForm&lt;SingleSessionFormValues&gt;({&#10;        defaultValues: {&#10;            startDate: new Date(),&#10;            startTime: '19:00',&#10;            durationHours: 2,&#10;            salesStartRuleType: SalesStartRuleType.ROLLING,&#10;            salesStartHoursBefore: 168,&#10;            salesStartFixedDatetime: new Date(),&#10;            isDaysNotHours: true, // Field to track if user is entering days or hours&#10;        }&#10;    });&#10;&#10;    const salesStartHoursBefore = watch('salesStartHoursBefore');&#10;    const isDaysNotHours = watch('isDaysNotHours');&#10;&#10;    // Handle toggling between days and hours&#10;    const handleUnitToggle = (checked: boolean) =&gt; {&#10;        setValue('isDaysNotHours', checked);&#10;        if (checked) {&#10;            // Converting hours to days (rounded)&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24) * 24);&#10;        } else {&#10;            // Converting days to hours&#10;            setValue('salesStartHoursBefore', Math.round(salesStartHoursBefore / 24));&#10;        }&#10;    };&#10;&#10;    const onSubmit = (data: SingleSessionFormValues) =&gt; {&#10;        // Check if adding this session would exceed the limit&#10;        if (currentSessionCount &gt;= maxSessions) {&#10;            toast.error(`Cannot add more sessions. You have reached the limit of ${maxSessions} sessions.`);&#10;            return;&#10;        }&#10;&#10;        // Create the session start time by combining date and time&#10;        const startTime = setMinutes(&#10;            setHours(&#10;                data.startDate,&#10;                parseInt(data.startTime.split(':')[0])&#10;            ),&#10;            parseInt(data.startTime.split(':')[1])&#10;        );&#10;&#10;        // Calculate end time based on duration&#10;        const endTime = new Date(startTime.getTime() + data.durationHours * 60 * 60 * 1000);&#10;&#10;        // Create the session object&#10;        const newSession: SessionFormData = {&#10;            startTime: startTime.toISOString(),&#10;            endTime: endTime.toISOString(),&#10;            isOnline: false,&#10;            salesStartRuleType: data.salesStartRuleType,&#10;            ...(data.salesStartRuleType === SalesStartRuleType.ROLLING &amp;&amp; {&#10;                salesStartHoursBefore: data.salesStartHoursBefore,&#10;            }),&#10;            ...(data.salesStartRuleType === SalesStartRuleType.FIXED &amp;&amp; {&#10;                salesStartFixedDatetime: data.salesStartFixedDatetime.toISOString(),&#10;            }),&#10;            layoutData: {name: 'Default', layout: {blocks: []}}&#10;        };&#10;&#10;        onAdd(newSession);&#10;        setOpen(false);&#10;    };&#10;&#10;    return (&#10;        &lt;Dialog open={open} onOpenChange={setOpen}&gt;&#10;            &lt;DialogContent&gt;&#10;                &lt;DialogHeader&gt;&#10;                    &lt;DialogTitle&gt;Add Single Session&lt;/DialogTitle&gt;&#10;                    &lt;DialogDescription&gt;&#10;                        Configure the details for this session.&#10;                        {maxSessions &gt; 0 &amp;&amp; (&#10;                            &lt;span className=&quot;block mt-1 text-sm text-muted-foreground&quot;&gt;&#10;                                Limit: {currentSessionCount}/{maxSessions} sessions used.&#10;                            &lt;/span&gt;&#10;                        )}&#10;                    &lt;/DialogDescription&gt;&#10;                &lt;/DialogHeader&gt;&#10;                &lt;form onSubmit={handleSubmit(onSubmit)} className=&quot;space-y-4&quot;&gt;&#10;                    &lt;Controller name=&quot;startDate&quot; control={control} render={({field}) =&gt; (&#10;                        &lt;FormItem&gt;&#10;                            &lt;FormLabel&gt;Date&lt;/FormLabel&gt;&#10;                            &lt;Popover&gt;&#10;                                &lt;PopoverTrigger asChild&gt;&#10;                                    &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                        &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                        {field.value ? format(field.value, 'PPP') : &lt;span&gt;Pick a date&lt;/span&gt;}&#10;                                    &lt;/Button&gt;&#10;                                &lt;/PopoverTrigger&gt;&#10;                                &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                    &lt;Calendar&#10;                                        mode=&quot;single&quot;&#10;                                        selected={field.value}&#10;                                        onSelect={field.onChange}&#10;                                        autoFocus&#10;                                    /&gt;&#10;                                &lt;/PopoverContent&gt;&#10;                            &lt;/Popover&gt;&#10;                        &lt;/FormItem&gt;&#10;                    )}/&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;startTime&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Start Time&lt;/FormLabel&gt;&#10;                                &lt;FormControl&gt;&#10;                                    &lt;Input type=&quot;time&quot; {...field}/&gt;&#10;                                &lt;/FormControl&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                        &lt;Controller name=&quot;durationHours&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Duration (hours)&lt;/FormLabel&gt;&#10;                                &lt;FormControl&gt;&#10;                                    &lt;Input&#10;                                        type=&quot;number&quot;&#10;                                        min=&quot;0.5&quot;&#10;                                        step=&quot;0.5&quot;&#10;                                        {...field}&#10;                                        onChange={e =&gt; field.onChange(parseFloat(e.target.value))}&#10;                                    /&gt;&#10;                                &lt;/FormControl&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div className=&quot;grid grid-cols-2 gap-4&quot;&gt;&#10;                        &lt;Controller name=&quot;salesStartRuleType&quot; control={control} render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&#10;                                &lt;FormLabel&gt;Sales Start Rule&lt;/FormLabel&gt;&#10;                                &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;SelectTrigger&gt;&#10;                                            &lt;SelectValue/&gt;&#10;                                        &lt;/SelectTrigger&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;SelectContent&gt;&#10;                                        &lt;SelectItem value=&quot;IMMEDIATE&quot;&gt;Immediate&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;ROLLING&quot;&gt;Rolling (Before Event)&lt;/SelectItem&gt;&#10;                                        &lt;SelectItem value=&quot;FIXED&quot;&gt;Fixed Datetime&lt;/SelectItem&gt;&#10;                                    &lt;/SelectContent&gt;&#10;                                &lt;/Select&gt;&#10;                            &lt;/FormItem&gt;&#10;                        )}/&gt;&#10;&#10;                        {watch('salesStartRuleType') === 'ROLLING' &amp;&amp; (&#10;                            &lt;div className=&quot;space-y-2&quot;&gt;&#10;                                &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                    &lt;FormLabel&gt;Unit&lt;/FormLabel&gt;&#10;                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Hours&lt;/span&gt;&#10;                                        &lt;Controller&#10;                                            name=&quot;isDaysNotHours&quot;&#10;                                            control={control}&#10;                                            render={({field}) =&gt; (&#10;                                                &lt;Switch&#10;                                                    checked={field.value}&#10;                                                    onCheckedChange={handleUnitToggle}&#10;                                                /&gt;&#10;                                            )}&#10;                                        /&gt;&#10;                                        &lt;span className=&quot;text-sm text-muted-foreground&quot;&gt;Days&lt;/span&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                &lt;Controller&#10;                                    name=&quot;salesStartHoursBefore&quot;&#10;                                    control={control}&#10;                                    render={({field}) =&gt; (&#10;                                        &lt;FormItem&gt;&#10;                                            &lt;FormLabel&gt;&#10;                                                {isDaysNotHours ? 'Days before event' : 'Hours before event'}&#10;                                            &lt;/FormLabel&gt;&#10;                                            &lt;FormControl&gt;&#10;                                                &lt;Input&#10;                                                    type=&quot;number&quot;&#10;                                                    min=&quot;1&quot;&#10;                                                    {...field}&#10;                                                    value={isDaysNotHours ? Math.round(field.value / 24) : field.value}&#10;                                                    onChange={(e) =&gt; {&#10;                                                        const value = parseInt(e.target.value);&#10;                                                        if (isDaysNotHours) {&#10;                                                            // If days, store as hours in the form data&#10;                                                            field.onChange(value * 24);&#10;                                                        } else {&#10;                                                            field.onChange(value);&#10;                                                        }&#10;                                                    }}&#10;                                                /&gt;&#10;                                            &lt;/FormControl&gt;&#10;                                        &lt;/FormItem&gt;&#10;                                    )}&#10;                                /&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;&#10;                        {watch('salesStartRuleType') === 'FIXED' &amp;&amp; (&#10;                            &lt;Controller name=&quot;salesStartFixedDatetime&quot; control={control} render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Sales Start Date&lt;/FormLabel&gt;&#10;                                    &lt;Popover&gt;&#10;                                        &lt;PopoverTrigger asChild&gt;&#10;                                            &lt;Button variant=&quot;outline&quot; className=&quot;w-full justify-start font-normal&quot;&gt;&#10;                                                &lt;CalendarIcon className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                                                {field.value ? format(field.value, 'PPP p') : &lt;span&gt;Pick a datetime&lt;/span&gt;}&#10;                                            &lt;/Button&gt;&#10;                                        &lt;/PopoverTrigger&gt;&#10;                                        &lt;PopoverContent className=&quot;w-auto p-0&quot;&gt;&#10;                                            &lt;Calendar&#10;                                                mode=&quot;single&quot;&#10;                                                selected={field.value}&#10;                                                onSelect={field.onChange}&#10;                                                autoFocus&#10;                                            /&gt;&#10;                                        &lt;/PopoverContent&gt;&#10;                                    &lt;/Popover&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}/&gt;&#10;                        )}&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;DialogFooter&gt;&#10;                        &lt;Button type=&quot;submit&quot;&gt;Add Session&lt;/Button&gt;&#10;                    &lt;/DialogFooter&gt;&#10;                &lt;/form&gt;&#10;            &lt;/DialogContent&gt;&#10;        &lt;/Dialog&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/TierStep.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/TierStep.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useFormContext, useFieldArray} from 'react-hook-form';&#10;import {CreateEventFormData} from '@/lib/validators/event';&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {PlusCircle, Trash2} from 'lucide-react';&#10;&#10;export function TiersStep() {&#10;    const {control, formState: {errors}} = useFormContext&lt;CreateEventFormData&gt;();&#10;&#10;    const {fields, append, remove} = useFieldArray({&#10;        control,&#10;        name: &quot;tiers&quot;,&#10;    });&#10;&#10;    // Add default &quot;General Admission&quot; tier when component mounts if no tiers exist&#10;    React.useEffect(() =&gt; {&#10;        if (fields.length === 0) {&#10;            append({&#10;                id: `default_tier_${Date.now()}`,&#10;                name: 'General Admission',&#10;                price: 0,&#10;                color: '#3B82F6' // Blue color&#10;            });&#10;        }&#10;    }, [fields.length, append]);&#10;&#10;    const addNewTier = () =&gt; {&#10;        append({&#10;            id: `temp_tier_${Date.now()}`, // Temporary client ID&#10;            name: '',&#10;            price: 0,&#10;            color: '#FFFFFF' // Default color&#10;        });&#10;    };&#10;&#10;    return (&#10;        &lt;Card&gt;&#10;            &lt;CardHeader&gt;&#10;                &lt;CardTitle&gt;Tiers &amp; Pricing&lt;/CardTitle&gt;&#10;                &lt;CardDescription&gt;&#10;                    Create different ticket types for your event. You will assign these to seats in a later step.&#10;                &lt;/CardDescription&gt;&#10;            &lt;/CardHeader&gt;&#10;            &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                {fields.length === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;py-4 text-center text-muted-foreground&quot;&gt;&#10;                        No tiers added yet. Click &amp;#34;Add Tier&amp;#34; to create your first ticket tier.&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;div key={field.id} className=&quot;flex items-end gap-4 p-4 border rounded-lg&quot;&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.name`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem className=&quot;flex-1&quot;&gt;&#10;                                    &lt;FormLabel&gt;Tier Name&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input placeholder=&quot;e.g., VIP&quot; {...field} /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.price`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Price&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input&#10;                                            type=&quot;number&quot;&#10;                                            min=&quot;0&quot;&#10;                                            placeholder=&quot;50.00&quot;&#10;                                            {...field}&#10;                                            onChange={e =&gt; field.onChange(parseFloat(e.target.value) || 0)}&#10;                                        /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.color`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Color&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input type=&quot;color&quot; className=&quot;p-1 h-10&quot; {...field} /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot; onClick={() =&gt; remove(index)}&gt;&#10;                            &lt;Trash2 className=&quot;h-4 w-4&quot;/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                ))}&#10;&#10;                &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={addNewTier}&gt;&#10;                    &lt;PlusCircle className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                    Add Tier&#10;                &lt;/Button&gt;&#10;&#10;                {/* This will display the root error for the tiers array (e.g., &quot;You must create at least one tier.&quot;) */}&#10;                {errors.tiers?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.tiers.root.message}&lt;/p&gt;&#10;                )}&#10;            &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useEffect, useRef} from 'react';&#10;import {useFormContext, useFieldArray} from 'react-hook-form';&#10;import {CreateEventFormData} from '@/lib/validators/event';&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {PlusCircle, Trash2} from 'lucide-react';&#10;&#10;export function TiersStep() {&#10;    const {control, formState: {errors}} = useFormContext&lt;CreateEventFormData&gt;();&#10;    const initialRenderRef = useRef(true);&#10;&#10;    const {fields, append, remove} = useFieldArray({&#10;        control,&#10;        name: &quot;tiers&quot;,&#10;    });&#10;    &#10;    // Add default &quot;General Admission&quot; tier only on initial render&#10;    useEffect(() =&gt; {&#10;        if (initialRenderRef.current &amp;&amp; fields.length === 0) {&#10;            append({&#10;                id: `default_tier_${Date.now()}`,&#10;                name: 'General Admission',&#10;                price: 0,&#10;                color: '#3B82F6' // Blue color&#10;            });&#10;        }&#10;        initialRenderRef.current = false;&#10;    }, []);&#10;&#10;    const addNewTier = () =&gt; {&#10;        append({&#10;            id: `temp_tier_${Date.now()}`, // Temporary client ID&#10;            name: '',&#10;            price: 0,&#10;            color: '#FFFFFF' // Default color&#10;        });&#10;    };&#10;&#10;    return (&#10;        &lt;Card&gt;&#10;            &lt;CardHeader&gt;&#10;                &lt;CardTitle&gt;Tiers &amp; Pricing&lt;/CardTitle&gt;&#10;                &lt;CardDescription&gt;&#10;                    Create different ticket types for your event. You will assign these to seats in a later step.&#10;                &lt;/CardDescription&gt;&#10;            &lt;/CardHeader&gt;&#10;            &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                {fields.length === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;py-4 text-center text-muted-foreground&quot;&gt;&#10;                        No tiers added yet. Click &amp;#34;Add Tier&amp;#34; to create your first ticket tier.&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {fields.map((field, index) =&gt; (&#10;                    &lt;div key={field.id} className=&quot;flex items-end gap-4 p-4 border rounded-lg&quot;&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.name`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem className=&quot;flex-1&quot;&gt;&#10;                                    &lt;FormLabel&gt;Tier Name&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input placeholder=&quot;e.g., VIP&quot; {...field} /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.price`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Price&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input&#10;                                            type=&quot;number&quot;&#10;                                            min=&quot;0&quot;&#10;                                            placeholder=&quot;50.00&quot;&#10;                                            {...field}&#10;                                            onChange={e =&gt; field.onChange(parseFloat(e.target.value) || 0)}&#10;                                        /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;FormField&#10;                            control={control}&#10;                            name={`tiers.${index}.color`}&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Color&lt;/FormLabel&gt;&#10;                                    &lt;FormControl&gt;&#10;                                        &lt;Input type=&quot;color&quot; className=&quot;p-1 h-10&quot; {...field} /&gt;&#10;                                    &lt;/FormControl&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;                        &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot; onClick={() =&gt; remove(index)}&gt;&#10;                            &lt;Trash2 className=&quot;h-4 w-4&quot;/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                ))}&#10;&#10;                &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={addNewTier}&gt;&#10;                    &lt;PlusCircle className=&quot;mr-2 h-4 w-4&quot;/&gt;&#10;                    Add Tier&#10;                &lt;/Button&gt;&#10;&#10;                {/* This will display the root error for the tiers array (e.g., &quot;You must create at least one tier.&quot;) */}&#10;                {errors.tiers?.root &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm font-medium text-destructive&quot;&gt;{errors.tiers.root.message}&lt;/p&gt;&#10;                )}&#10;            &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/coreDetailsStep.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/_components/coreDetailsStep.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect, useRef} from 'react';&#10;import {useForm, FormProvider} from 'react-hook-form';&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {useOrganization} from '@/providers/OrganizationProvider';&#10;import {useLimits} from '@/providers/LimitProvider';&#10;import {CategoryResponse} from '@/types/category';&#10;import {getAllCategories} from '@/lib/actions/categoryActions';&#10;import {coreDetailsSchema, CoreDetailsData} from '@/lib/validators/event';&#10;&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Textarea} from '@/components/ui/textarea';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {&#10;    Select,&#10;    SelectContent,&#10;    SelectItem,&#10;    SelectTrigger,&#10;    SelectValue,&#10;    SelectGroup,&#10;    SelectLabel&#10;} from '@/components/ui/select';&#10;import {Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious} from &quot;@/components/ui/carousel&quot;;&#10;import Image from 'next/image';&#10;import {ImageIcon, X, PlusCircle, Upload} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import Autoplay from 'embla-carousel-autoplay';&#10;&#10;// --- Step 1: Core Details Component ---&#10;export function CoreDetailsStep({onNextAction}: { onNextAction: () =&gt; void }) {&#10;    const {organization} = useOrganization();&#10;    const {myLimits} = useLimits();&#10;    const [categories, setCategories] = useState&lt;CategoryResponse[]&gt;([]);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;    const maxPhotos = myLimits?.eventLimits.maxCoverPhotos || 1;&#10;&#10;    const form = useForm&lt;CoreDetailsData&gt;({&#10;        resolver: zodResolver(coreDetailsSchema),&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            categoryId: '', // Ensure categoryId is present&#10;            isOnline: false,&#10;        },&#10;    });&#10;&#10;    useEffect(() =&gt; {&#10;        getAllCategories().then(setCategories);&#10;    }, [organization]);&#10;&#10;    const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;        if (e.target.files) {&#10;            const files = Array.from(e.target.files);&#10;            if ((coverFiles.length + files.length) &gt; maxPhotos) {&#10;                toast.error(`You can only upload a maximum of ${maxPhotos} photos.`);&#10;                return;&#10;            }&#10;            setCoverFiles(prev =&gt; [...prev, ...files]);&#10;        }&#10;    };&#10;&#10;    const removeImage = (index: number) =&gt; {&#10;        setCoverFiles(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;    };&#10;&#10;    function onSubmit(data: CoreDetailsData) {&#10;        console.log(&quot;Step 1 Data:&quot;, data);&#10;        console.log(&quot;Cover Files:&quot;, coverFiles);&#10;        onNextAction();&#10;    }&#10;&#10;    return (&#10;        &lt;FormProvider {...form}&gt;&#10;            &lt;form onSubmit={form.handleSubmit(onSubmit)} className=&quot;space-y-8&quot;&gt;&#10;                {/* Hero Cover Photos Section */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Cover Photos&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;This is the first thing people will see. Upload up&#10;                            to {maxPhotos} images.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent&gt;&#10;                        {coverFiles.length &gt; 0 ? (&#10;                            &lt;Carousel plugins={[Autoplay({delay: 4000, stopOnInteraction: false})]}&gt;&#10;                                &lt;CarouselContent&gt;&#10;                                    {coverFiles.map((file, index) =&gt; (&#10;                                        &lt;CarouselItem key={index} className=&quot;relative&quot;&gt;&#10;                                            &lt;div className=&quot;aspect-[21/9] w-full relative&quot;&gt;&#10;                                                &lt;Image src={URL.createObjectURL(file)} alt={`Cover photo ${index + 1}`}&#10;                                                       fill className=&quot;object-cover rounded-lg&quot;/&gt;&#10;                                                &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot;&#10;                                                        className=&quot;absolute top-4 right-4 h-8 w-8 z-10&quot;&#10;                                                        onClick={() =&gt; removeImage(index)}&gt;&lt;X&#10;                                                    className=&quot;h-4 w-4&quot;/&gt;&lt;/Button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/CarouselItem&gt;&#10;                                    ))}&#10;                                &lt;/CarouselContent&gt;&#10;                                &lt;CarouselPrevious type=&quot;button&quot;&#10;                                                  className=&quot;absolute left-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                                &lt;CarouselNext type=&quot;button&quot;&#10;                                              className=&quot;absolute right-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                            &lt;/Carousel&gt;&#10;                        ) : (&#10;                            &lt;div&#10;                                className=&quot;flex flex-col items-center justify-center border-2 border-dashed rounded-lg p-12 text-center aspect-[21/9] w-full&quot;&gt;&#10;                                &lt;ImageIcon className=&quot;h-16 w-16 text-muted-foreground&quot;/&gt;&#10;                                &lt;p className=&quot;mt-4 text-lg font-medium&quot;&gt;Add cover photos for your event&lt;/p&gt;&#10;                                &lt;Button type=&quot;button&quot; className=&quot;mt-4&quot;&#10;                                        onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;Upload className=&quot;mr-2 h-4 w-4&quot;/&gt;Upload&#10;                                    Images&lt;/Button&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;                        &lt;div className=&quot;mt-4 flex justify-center items-center gap-4&quot;&gt;&#10;                            {coverFiles.length &gt; 0 &amp;&amp; (&lt;Button type=&quot;button&quot; variant=&quot;outline&quot;&#10;                                                               onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;PlusCircle&#10;                                className=&quot;mr-2 h-4 w-4&quot;/&gt;Add More&lt;/Button&gt;)}&#10;                            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{coverFiles.length} of {maxPhotos} photos&#10;                                selected.&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;Input id=&quot;picture&quot; type=&quot;file&quot; multiple accept=&quot;image/*&quot; onChange={handleFileChange}&#10;                               className=&quot;hidden&quot; ref={fileInputRef}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;&#10;                {/* Event Details Card with Category dropdown */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Event Details&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;Provide the core information about your event.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                        &lt;FormField control={form.control} name=&quot;title&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Event Title&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                placeholder=&quot;e.g., Annual Tech Conference 2025&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;&#10;                        {/* Category Selector as dropdown */}&#10;                        &lt;FormField&#10;                            control={form.control}&#10;                            name=&quot;categoryId&quot;&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Category&lt;/FormLabel&gt;&#10;                                    &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                        &lt;FormControl&gt;&#10;                                            &lt;SelectTrigger&gt;&#10;                                                &lt;SelectValue placeholder=&quot;Select a category for your event&quot;/&gt;&#10;                                            &lt;/SelectTrigger&gt;&#10;                                        &lt;/FormControl&gt;&#10;                                        &lt;SelectContent className=&quot;max-h-100&quot;&gt;&#10;                                            {categories.map((parentCat) =&gt; (&#10;                                                &lt;SelectGroup key={parentCat.id}&gt;&#10;                                                    &lt;SelectLabel&gt;{parentCat.name}&lt;/SelectLabel&gt;&#10;                                                    {parentCat.subCategories.map((subCat) =&gt; (&#10;                                                        &lt;SelectItem key={subCat.id} value={subCat.id}&gt;&#10;                                                            {subCat.name}&#10;                                                        &lt;/SelectItem&gt;&#10;                                                    ))}&#10;                                                &lt;/SelectGroup&gt;&#10;                                            ))}&#10;                                        &lt;/SelectContent&gt;&#10;                                    &lt;/Select&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;&#10;                        &lt;FormField control={form.control} name=&quot;description&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Short Description&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;A brief summary of your event.&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                        &lt;FormField control={form.control} name=&quot;overview&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Overview&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;Provide more details like schedule, speakers, etc.&quot;&#10;                                className=&quot;min-h-32&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;                &lt;div className=&quot;flex justify-end mt-8&quot;&gt;&#10;                    &lt;Button type=&quot;submit&quot;&gt;Next: Tiers &amp; Pricing&lt;/Button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/form&gt;&#10;        &lt;/FormProvider&gt;&#10;    )&#10;}" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useState, useEffect, useRef} from 'react';&#10;import {useForm, FormProvider} from 'react-hook-form';&#10;import {zodResolver} from '@hookform/resolvers/zod';&#10;import {useOrganization} from '@/providers/OrganizationProvider';&#10;import {useLimits} from '@/providers/LimitProvider';&#10;import {CategoryResponse} from '@/types/category';&#10;import {getAllCategories} from '@/lib/actions/categoryActions';&#10;import {coreDetailsSchema, CoreDetailsData} from '@/lib/validators/event';&#10;&#10;import {Button} from '@/components/ui/button';&#10;import {Input} from '@/components/ui/input';&#10;import {Textarea} from '@/components/ui/textarea';&#10;import {Card, CardContent, CardDescription, CardHeader, CardTitle} from '@/components/ui/card';&#10;import {FormControl, FormField, FormItem, FormLabel, FormMessage} from '@/components/ui/form';&#10;import {&#10;    Select,&#10;    SelectContent,&#10;    SelectItem,&#10;    SelectTrigger,&#10;    SelectValue,&#10;    SelectGroup,&#10;    SelectLabel&#10;} from '@/components/ui/select';&#10;import {Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious} from &quot;@/components/ui/carousel&quot;;&#10;import Image from 'next/image';&#10;import {ImageIcon, X, PlusCircle, Upload} from 'lucide-react';&#10;import {toast} from 'sonner';&#10;import Autoplay from 'embla-carousel-autoplay';&#10;&#10;// Updated props interface to match the required signature&#10;interface CoreDetailsStepProps {&#10;    coverFiles: File[];&#10;    setCoverFilesAction: React.Dispatch&lt;React.SetStateAction&lt;File[]&gt;&gt;;&#10;    onNextAction?: () =&gt; void;&#10;}&#10;&#10;// --- Step 1: Core Details Component ---&#10;export function CoreDetailsStep({ coverFiles, setCoverFilesAction, onNextAction }: CoreDetailsStepProps) {&#10;    const {organization} = useOrganization();&#10;    const {myLimits} = useLimits();&#10;    const [categories, setCategories] = useState&lt;CategoryResponse[]&gt;([]);&#10;    const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;    const maxPhotos = myLimits?.eventLimits.maxCoverPhotos || 1;&#10;&#10;    const form = useForm&lt;CoreDetailsData&gt;({&#10;        resolver: zodResolver(coreDetailsSchema),&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            categoryId: '', // Ensure categoryId is present&#10;            isOnline: false,&#10;        },&#10;    });&#10;&#10;    useEffect(() =&gt; {&#10;        getAllCategories().then(setCategories);&#10;    }, [organization]);&#10;&#10;    const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;        if (e.target.files) {&#10;            const files = Array.from(e.target.files);&#10;            if ((coverFiles.length + files.length) &gt; maxPhotos) {&#10;                toast.error(`You can only upload a maximum of ${maxPhotos} photos.`);&#10;                return;&#10;            }&#10;            setCoverFilesAction(prev =&gt; [...prev, ...files]);&#10;        }&#10;    };&#10;&#10;    const removeImage = (index: number) =&gt; {&#10;        setCoverFilesAction(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;    };&#10;&#10;    function onSubmit(data: CoreDetailsData) {&#10;        console.log(&quot;Step 1 Data:&quot;, data);&#10;        console.log(&quot;Cover Files:&quot;, coverFiles);&#10;        if (onNextAction) onNextAction();&#10;    }&#10;&#10;    return (&#10;        &lt;FormProvider {...form}&gt;&#10;            &lt;form onSubmit={form.handleSubmit(onSubmit)} className=&quot;space-y-8&quot;&gt;&#10;                {/* Hero Cover Photos Section */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Cover Photos&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;This is the first thing people will see. Upload up&#10;                            to {maxPhotos} images.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent&gt;&#10;                        {coverFiles.length &gt; 0 ? (&#10;                            &lt;Carousel plugins={[Autoplay({delay: 4000, stopOnInteraction: false})]}&gt;&#10;                                &lt;CarouselContent&gt;&#10;                                    {coverFiles.map((file, index) =&gt; (&#10;                                        &lt;CarouselItem key={index} className=&quot;relative&quot;&gt;&#10;                                            &lt;div className=&quot;aspect-[21/9] w-full relative&quot;&gt;&#10;                                                &lt;Image src={URL.createObjectURL(file)} alt={`Cover photo ${index + 1}`}&#10;                                                       fill className=&quot;object-cover rounded-lg&quot;/&gt;&#10;                                                &lt;Button type=&quot;button&quot; variant=&quot;destructive&quot; size=&quot;icon&quot;&#10;                                                        className=&quot;absolute top-4 right-4 h-8 w-8 z-10&quot;&#10;                                                        onClick={() =&gt; removeImage(index)}&gt;&lt;X&#10;                                                    className=&quot;h-4 w-4&quot;/&gt;&lt;/Button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/CarouselItem&gt;&#10;                                    ))}&#10;                                &lt;/CarouselContent&gt;&#10;                                &lt;CarouselPrevious type=&quot;button&quot;&#10;                                                  className=&quot;absolute left-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                                &lt;CarouselNext type=&quot;button&quot;&#10;                                              className=&quot;absolute right-4 bg-black/50 text-white border-none hover:bg-black/75&quot;/&gt;&#10;                            &lt;/Carousel&gt;&#10;                        ) : (&#10;                            &lt;div&#10;                                className=&quot;flex flex-col items-center justify-center border-2 border-dashed rounded-lg p-12 text-center aspect-[21/9] w-full&quot;&gt;&#10;                                &lt;ImageIcon className=&quot;h-16 w-16 text-muted-foreground&quot;/&gt;&#10;                                &lt;p className=&quot;mt-4 text-lg font-medium&quot;&gt;Add cover photos for your event&lt;/p&gt;&#10;                                &lt;Button type=&quot;button&quot; className=&quot;mt-4&quot;&#10;                                        onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;Upload className=&quot;mr-2 h-4 w-4&quot;/&gt;Upload&#10;                                    Images&lt;/Button&gt;&#10;                            &lt;/div&gt;&#10;                        )}&#10;                        &lt;div className=&quot;mt-4 flex justify-center items-center gap-4&quot;&gt;&#10;                            {coverFiles.length &gt; 0 &amp;&amp; (&lt;Button type=&quot;button&quot; variant=&quot;outline&quot;&#10;                                                               onClick={() =&gt; fileInputRef.current?.click()}&gt;&lt;PlusCircle&#10;                                className=&quot;mr-2 h-4 w-4&quot;/&gt;Add More&lt;/Button&gt;)}&#10;                            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{coverFiles.length} of {maxPhotos} photos&#10;                                selected.&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;Input id=&quot;picture&quot; type=&quot;file&quot; multiple accept=&quot;image/*&quot; onChange={handleFileChange}&#10;                               className=&quot;hidden&quot; ref={fileInputRef}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;&#10;                {/* Event Details Card with Category dropdown */}&#10;                &lt;Card&gt;&#10;                    &lt;CardHeader&gt;&#10;                        &lt;CardTitle&gt;Event Details&lt;/CardTitle&gt;&#10;                        &lt;CardDescription&gt;Provide the core information about your event.&lt;/CardDescription&gt;&#10;                    &lt;/CardHeader&gt;&#10;                    &lt;CardContent className=&quot;space-y-6&quot;&gt;&#10;                        &lt;FormField control={form.control} name=&quot;title&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Event Title&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Input&#10;                                placeholder=&quot;e.g., Annual Tech Conference 2025&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;&#10;                        {/* Category Selector as dropdown */}&#10;                        &lt;FormField&#10;                            control={form.control}&#10;                            name=&quot;categoryId&quot;&#10;                            render={({field}) =&gt; (&#10;                                &lt;FormItem&gt;&#10;                                    &lt;FormLabel&gt;Category&lt;/FormLabel&gt;&#10;                                    &lt;Select onValueChange={field.onChange} defaultValue={field.value}&gt;&#10;                                        &lt;FormControl&gt;&#10;                                            &lt;SelectTrigger&gt;&#10;                                                &lt;SelectValue placeholder=&quot;Select a category for your event&quot;/&gt;&#10;                                            &lt;/SelectTrigger&gt;&#10;                                        &lt;/FormControl&gt;&#10;                                        &lt;SelectContent className=&quot;max-h-100&quot;&gt;&#10;                                            {categories.map((parentCat) =&gt; (&#10;                                                &lt;SelectGroup key={parentCat.id}&gt;&#10;                                                    &lt;SelectLabel&gt;{parentCat.name}&lt;/SelectLabel&gt;&#10;                                                    {parentCat.subCategories.map((subCat) =&gt; (&#10;                                                        &lt;SelectItem key={subCat.id} value={subCat.id}&gt;&#10;                                                            {subCat.name}&#10;                                                        &lt;/SelectItem&gt;&#10;                                                    ))}&#10;                                                &lt;/SelectGroup&gt;&#10;                                            ))}&#10;                                        &lt;/SelectContent&gt;&#10;                                    &lt;/Select&gt;&#10;                                    &lt;FormMessage/&gt;&#10;                                &lt;/FormItem&gt;&#10;                            )}&#10;                        /&gt;&#10;&#10;                        &lt;FormField control={form.control} name=&quot;description&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Short Description&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;A brief summary of your event.&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                        &lt;FormField control={form.control} name=&quot;overview&quot; render={({field}) =&gt; (&#10;                            &lt;FormItem&gt;&lt;FormLabel&gt;Overview&lt;/FormLabel&gt;&lt;FormControl&gt;&lt;Textarea&#10;                                placeholder=&quot;Provide more details like schedule, speakers, etc.&quot;&#10;                                className=&quot;min-h-32&quot; {...field} /&gt;&lt;/FormControl&gt;&lt;FormMessage/&gt;&lt;/FormItem&gt;)}/&gt;&#10;                    &lt;/CardContent&gt;&#10;                &lt;/Card&gt;&#10;                &lt;div className=&quot;flex justify-end mt-8&quot;&gt;&#10;                    &lt;Button type=&quot;submit&quot;&gt;Next: Tiers &amp; Pricing&lt;/Button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/form&gt;&#10;        &lt;/FormProvider&gt;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx.new">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/manage/organization/[organization_id]/event/create/page.tsx.new" />
              <option name="updatedContent" value="'use client';&#10;&#10;import * as React from 'react';&#10;import {useEffect, useState} from 'react';&#10;import {CoreDetailsStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/CoreDetailsStep&quot;;&#10;import {Progress} from &quot;@/components/ui/progress&quot;;&#10;import {CreateEventRequest} from &quot;@/types/event&quot;;&#10;import {toast} from &quot;sonner&quot;;&#10;import {FormProvider, useForm} from &quot;react-hook-form&quot;;&#10;import {Button} from &quot;@/components/ui/button&quot;;&#10;import {TiersStep} from &quot;@/app/manage/organization/[organization_id]/event/_components/TierStep&quot;;&#10;import {zodResolver} from &quot;@hookform/resolvers/zod&quot;;&#10;import {coreDetailsSchema, tiersSchema} from &quot;@/lib/validators/event&quot;;&#10;import {WizardSidebar} from &quot;../_components/WizardSideBar&quot;;&#10;import {useSidebar} from &quot;@/components/ui/sidebar&quot;;&#10;&#10;// --- Main Wizard Parent Component ---&#10;export default function CreateEventPage() {&#10;    const [step, setStep] = useState(1);&#10;    const [coverFiles, setCoverFiles] = useState&lt;File[]&gt;([]);&#10;    const totalSteps = 5;&#10;    const {setOpen} = useSidebar();&#10;    &#10;    const steps = [&#10;        {number: 1, title: &quot;Core Details&quot;, description: &quot;Name, category, and location&quot;},&#10;        {number: 2, title: &quot;Tiers &amp; Pricing&quot;, description: &quot;Set your ticket prices&quot;},&#10;        {number: 3, title: &quot;Scheduling&quot;, description: &quot;Add dates and times&quot;},&#10;        {number: 4, title: &quot;Seating&quot;, description: &quot;Configure seating maps&quot;},&#10;        {number: 5, title: &quot;Review &amp; Publish&quot;, description: &quot;Final check before submission&quot;},&#10;    ];&#10;&#10;    // Collapse the main sidebar when component mounts&#10;    useEffect(() =&gt; {&#10;        setOpen(false);&#10;    }, [setOpen]);&#10;&#10;    //  The single form instance for the entire wizard is created here.&#10;    const methods = useForm&lt;CreateEventRequest&gt;({&#10;        defaultValues: {&#10;            title: '',&#10;            description: '',&#10;            overview: '',&#10;            organizationId: '', // Should be set from context/params&#10;            categoryId: '',&#10;            isOnline: false,&#10;            tiers: [],&#10;            sessions: [],&#10;        },&#10;        mode: 'onSubmit', // Only validate when explicitly triggered&#10;    });&#10;&#10;    // Update the validation schema based on the current step&#10;    useEffect(() =&gt; {&#10;        if (step === 1) {&#10;            methods.clearErrors();&#10;        } else if (step === 2) {&#10;            methods.clearErrors();&#10;        }&#10;    }, [step, methods]);&#10;&#10;    const validateCoreDetails = async () =&gt; {&#10;        try {&#10;            // Check for cover photos&#10;            if (coverFiles.length === 0) {&#10;                toast.error(&quot;Please upload at least one cover photo.&quot;);&#10;                return false;&#10;            }&#10;            &#10;            // Get form values for core details&#10;            const values = methods.getValues();&#10;            const coreData = {&#10;                title: values.title,&#10;                description: values.description || &quot;&quot;,&#10;                overview: values.overview || &quot;&quot;,&#10;                categoryId: values.categoryId || &quot;&quot;,&#10;                isOnline: values.isOnline || false,&#10;                venueId: values.venueId,&#10;                onlineLink: values.onlineLink,&#10;                locationDescription: values.locationDescription,&#10;            };&#10;            &#10;            // Validate with Zod schema&#10;            const result = coreDetailsSchema.safeParse(coreData);&#10;            &#10;            if (!result.success) {&#10;                // Show validation errors&#10;                result.error.errors.forEach(err =&gt; {&#10;                    toast.error(`${err.path.join('.')}: ${err.message}`);&#10;                });&#10;                &#10;                // Also set form errors for field highlighting&#10;                result.error.errors.forEach(err =&gt; {&#10;                    const path = err.path.join('.') as keyof CreateEventRequest;&#10;                    methods.setError(path, { &#10;                        type: 'manual', &#10;                        message: err.message &#10;                    });&#10;                });&#10;                &#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        } catch (error: any) {&#10;            console.error(&quot;Validation error:&quot;, error);&#10;            toast.error(&quot;Please check all required fields&quot;);&#10;            return false;&#10;        }&#10;    };&#10;&#10;    const validateTiers = async () =&gt; {&#10;        try {&#10;            // Get tiers data&#10;            const values = methods.getValues();&#10;            const tiersData = { tiers: values.tiers || [] };&#10;            &#10;            // Validate with Zod schema&#10;            const result = tiersSchema.safeParse(tiersData);&#10;            &#10;            if (!result.success) {&#10;                // Show validation errors&#10;                result.error.errors.forEach(err =&gt; {&#10;                    toast.error(`${err.message}`);&#10;                });&#10;                return false;&#10;            }&#10;            &#10;            return true;&#10;        } catch (error: any) {&#10;            console.error(&quot;Tier validation error:&quot;, error);&#10;            toast.error(&quot;Please add at least one tier with valid information&quot;);&#10;            return false;&#10;        }&#10;    };&#10;&#10;    const onNext = async () =&gt; {&#10;        let isValid = false;&#10;        &#10;        if (step === 1) {&#10;            isValid = await validateCoreDetails();&#10;        } else if (step === 2) {&#10;            isValid = await validateTiers();&#10;        } else {&#10;            // For future steps that don't have validation yet&#10;            isValid = true;&#10;        }&#10;&#10;        if (isValid) {&#10;            setStep(s =&gt; Math.min(totalSteps, s + 1));&#10;        }&#10;    };&#10;&#10;    const onPrev = () =&gt; setStep(s =&gt; Math.max(1, s - 1));&#10;&#10;    const onSubmit = async (data: CreateEventRequest) =&gt; {&#10;        // Perform final validation before submission&#10;        let isValid = true;&#10;        &#10;        // Validate the current step first&#10;        if (step === 1) {&#10;            isValid = await validateCoreDetails();&#10;        } else if (step === 2) {&#10;            isValid = await validateTiers();&#10;        }&#10;        &#10;        if (isValid) {&#10;            console.log(&quot;Final Assembled Form Data:&quot;, data);&#10;            console.log(&quot;Final Cover Files:&quot;, coverFiles);&#10;            // Here you would call your createEvent API action&#10;            toast.success(&quot;Event submitted for approval!&quot;);&#10;        }&#10;    };&#10;&#10;    const renderStep = () =&gt; {&#10;        switch (step) {&#10;            case 1:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;            case 2:&#10;                return &lt;TiersStep/&gt;;&#10;            // Add cases for other steps here&#10;            default:&#10;                return &lt;CoreDetailsStep coverFiles={coverFiles} setCoverFilesAction={setCoverFiles}/&gt;;&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div className=&quot;flex min-h-screen bg-muted/40&quot;&gt;&#10;            &lt;WizardSidebar currentStep={step} steps={steps}/&gt;&#10;            &lt;main className=&quot;flex-1 p-4 md:p-8 overflow-y-auto ml-72&quot;&gt;&#10;                &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;&#10;                    &lt;div className=&quot;mb-8&quot;&gt;&#10;                        &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;Step {step} of {totalSteps}&lt;/p&gt;&#10;                        &lt;Progress value={(step / totalSteps) * 100} className=&quot;mt-2&quot;/&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    {/*  The FormProvider broadcasts the form state to all children */}&#10;                    &lt;FormProvider {...methods}&gt;&#10;                        &lt;form onSubmit={methods.handleSubmit(onSubmit)}&gt;&#10;                            {renderStep()}&#10;&#10;                            &lt;div className=&quot;flex justify-between mt-8&quot;&gt;&#10;                                &lt;Button type=&quot;button&quot; variant=&quot;outline&quot; onClick={onPrev} disabled={step === 1}&gt;&#10;                                    Previous&#10;                                &lt;/Button&gt;&#10;                                {step &lt; totalSteps ? (&#10;                                    &lt;Button type=&quot;button&quot; onClick={onNext}&gt;&#10;                                        Next&#10;                                    &lt;/Button&gt;&#10;                                ) : (&#10;                                    &lt;Button type=&quot;submit&quot;&gt;&#10;                                        Submit for Approval&#10;                                    &lt;/Button&gt;&#10;                                )}&#10;                            &lt;/div&gt;&#10;                        &lt;/form&gt;&#10;                    &lt;/FormProvider&gt;&#10;                &lt;/div&gt;&#10;            &lt;/main&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/validators/event.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/validators/event.ts" />
              <option name="originalContent" value="import { z } from 'zod';&#10;import {SalesStartRuleType} from &quot;@/types/event&quot;;&#10;&#10;const positionSchema = z.object({&#10;    x: z.number(),&#10;    y: z.number(),&#10;});&#10;&#10;const seatSchema = z.object({&#10;    id: z.string(),&#10;    label: z.string(),&#10;    tierId: z.string().optional(),&#10;    status: z.enum(['AVAILABLE', 'RESERVED']).optional(),&#10;});&#10;&#10;const rowSchema = z.object({&#10;    id: z.string(),&#10;    label: z.string(),&#10;    seats: z.array(seatSchema),&#10;});&#10;&#10;const blockSchema = z.object({&#10;    id: z.string(),&#10;    name: z.string().min(1, &quot;Block name is required.&quot;),&#10;    type: z.enum(['seated_grid', 'standing_capacity', 'non_sellable']),&#10;    position: positionSchema,&#10;    rows: z.array(rowSchema).optional(),&#10;    capacity: z.number().optional(),&#10;    seats: z.array(seatSchema).optional(),&#10;    width: z.number().optional(),&#10;    height: z.number().optional(),&#10;});&#10;&#10;const layoutSchema = z.object({&#10;    blocks: z.array(blockSchema),&#10;});&#10;&#10;const sessionSeatingMapRequestSchema = z.object({&#10;    name: z.string(),&#10;    layout: layoutSchema,&#10;});&#10;&#10;&#10;// --- Venue &amp; Tier Schemas ---&#10;&#10;const venueDetailsSchema = z.object({&#10;    name: z.string().min(1, &quot;Venue name is required.&quot;),&#10;    address: z.string().optional(),&#10;    latitude: z.number().optional(),&#10;    longitude: z.number().optional(),&#10;});&#10;&#10;const tierSchema = z.object({&#10;    id: z.string(),&#10;    name: z.string().min(1, { message: &quot;Tier name cannot be empty.&quot; }),&#10;    price: z.number().min(0, { message: &quot;Price must be a positive number.&quot; }),&#10;    color: z.string().optional(),&#10;});&#10;&#10;&#10;// --- Session Schema with Conditional Logic ---&#10;&#10;const sessionSchema = z.object({&#10;    startTime: z.string().datetime({ message: &quot;Invalid start date format.&quot; }),&#10;    endTime: z.string().datetime({ message: &quot;Invalid end date format.&quot; }),&#10;    salesStartRuleType: z.nativeEnum(SalesStartRuleType),&#10;    salesStartHoursBefore: z.number().optional(),&#10;    salesStartFixedDatetime: z.string().datetime({ message: &quot;Invalid date format.&quot; }).optional(),&#10;    isOnline: z.boolean(),&#10;    onlineLink: z.string().optional(),&#10;    venueDetails: venueDetailsSchema.optional(),&#10;    layoutData: sessionSeatingMapRequestSchema,&#10;}).refine(data =&gt; {&#10;    // If it's an online event, the onlineLink must be a valid URL.&#10;    if (data.isOnline) {&#10;        return data.onlineLink &amp;&amp; z.string().url().safeParse(data.onlineLink).success;&#10;    }&#10;    return true;&#10;}, {&#10;    message: &quot;A valid URL is required for online events.&quot;,&#10;    path: [&quot;onlineLink&quot;],&#10;}).refine(data =&gt; {&#10;    // If it's a physical event, venueDetails must be provided.&#10;    if (!data.isOnline) {&#10;        return !!data.venueDetails;&#10;    }&#10;    return true;&#10;}, {&#10;    message: &quot;Venue details are required for physical events.&quot;,&#10;    path: [&quot;venueDetails&quot;],&#10;}).refine(data =&gt; {&#10;    // End time must be after start time&#10;    return new Date(data.endTime) &gt; new Date(data.startTime);&#10;}, {&#10;    message: &quot;End time must be after the start time.&quot;,&#10;    path: [&quot;endTime&quot;],&#10;});&#10;&#10;&#10;// --- Final Event Schema ---&#10;&#10;export const createEventSchema = z.object({&#10;    title: z.string().min(3, { message: &quot;Title must be at least 3 characters.&quot; }),&#10;    description: z.string().optional(),&#10;    overview: z.string().optional(),&#10;    organizationId: z.string().uuid(),&#10;    categoryId: z.string().uuid({ message: &quot;Please select a category.&quot; }),&#10;    tiers: z.array(tierSchema).min(1, { message: &quot;You must create at least one tier.&quot; }),&#10;    sessions: z.array(sessionSchema).min(1, { message: &quot;You must schedule at least one session.&quot; }),&#10;});&#10;&#10;// --- Type Inference ---&#10;&#10;export type CreateEventFormData = z.infer&lt;typeof createEventSchema&gt;;&#10;&#10;// --- Step-by-Step Validation Fields ---&#10;&#10;export const stepValidationFields = {&#10;    1: ['title', 'categoryId', 'description', 'overview'] as const,&#10;    2: ['tiers'] as const,&#10;    3: ['sessions'] as const,&#10;    // Step 4 is for seating, which is part of the session object&#10;    // Step 5 is for cover photos and review (handled separately)&#10;} as const;&#10;" />
              <option name="updatedContent" value="import { z } from 'zod';&#10;import {SalesStartRuleType} from &quot;@/types/event&quot;;&#10;&#10;const positionSchema = z.object({&#10;    x: z.number(),&#10;    y: z.number(),&#10;});&#10;&#10;const seatSchema = z.object({&#10;    id: z.string(),&#10;    label: z.string(),&#10;    tierId: z.string().optional(),&#10;    status: z.enum(['AVAILABLE', 'RESERVED']).optional(),&#10;});&#10;&#10;const rowSchema = z.object({&#10;    id: z.string(),&#10;    label: z.string(),&#10;    seats: z.array(seatSchema),&#10;});&#10;&#10;const blockSchema = z.object({&#10;    id: z.string(),&#10;    name: z.string().min(1, &quot;Block name is required.&quot;),&#10;    type: z.enum(['seated_grid', 'standing_capacity', 'non_sellable']),&#10;    position: positionSchema,&#10;    rows: z.array(rowSchema).optional(),&#10;    capacity: z.number().optional(),&#10;    seats: z.array(seatSchema).optional(),&#10;    width: z.number().optional(),&#10;    height: z.number().optional(),&#10;});&#10;&#10;const layoutSchema = z.object({&#10;    blocks: z.array(blockSchema),&#10;});&#10;&#10;const sessionSeatingMapRequestSchema = z.object({&#10;    name: z.string(),&#10;    layout: layoutSchema,&#10;});&#10;&#10;&#10;// --- Venue &amp; Tier Schemas ---&#10;&#10;const venueDetailsSchema = z.object({&#10;    name: z.string().min(1, &quot;Venue name is required.&quot;),&#10;    address: z.string().optional(),&#10;    latitude: z.number().optional(),&#10;    longitude: z.number().optional(),&#10;});&#10;&#10;const tierSchema = z.object({&#10;    id: z.string(),&#10;    name: z.string().min(1, { message: &quot;Tier name cannot be empty.&quot; }),&#10;    price: z.number().min(0, { message: &quot;Price must be a positive number.&quot; }),&#10;    color: z.string().optional(),&#10;});&#10;&#10;&#10;// --- Session Schema with Conditional Logic ---&#10;&#10;const sessionSchema = z.object({&#10;    startTime: z.string().pipe(z.coerce.date({&#10;        errorMap: () =&gt; ({ message: &quot;Invalid start date format.&quot; })&#10;    })),&#10;    endTime: z.string().pipe(z.coerce.date({&#10;        errorMap: () =&gt; ({ message: &quot;Invalid end date format.&quot; })&#10;    })),&#10;    salesStartRuleType: z.enum(Object.values(SalesStartRuleType) as [string, ...string[]]),&#10;    salesStartHoursBefore: z.number().optional(),&#10;    salesStartFixedDatetime: z.string().pipe(z.coerce.date({&#10;        errorMap: () =&gt; ({ message: &quot;Invalid date format.&quot; })&#10;    })).optional(),&#10;    isOnline: z.boolean(),&#10;    onlineLink: z.string().optional(),&#10;    venueDetails: venueDetailsSchema.optional(),&#10;    layoutData: sessionSeatingMapRequestSchema,&#10;}).refine(data =&gt; {&#10;    // If it's an online event, the onlineLink must be a valid URL.&#10;    if (data.isOnline) {&#10;        return data.onlineLink &amp;&amp; z.string().url().safeParse(data.onlineLink).success;&#10;    }&#10;    return true;&#10;}, {&#10;    message: &quot;A valid URL is required for online events.&quot;,&#10;    path: [&quot;onlineLink&quot;],&#10;}).refine(data =&gt; {&#10;    // If it's a physical event, venueDetails must be provided.&#10;    if (!data.isOnline) {&#10;        return !!data.venueDetails;&#10;    }&#10;    return true;&#10;}, {&#10;    message: &quot;Venue details are required for physical events.&quot;,&#10;    path: [&quot;venueDetails&quot;],&#10;}).refine(data =&gt; {&#10;    // End time must be after start time&#10;    return new Date(data.endTime) &gt; new Date(data.startTime);&#10;}, {&#10;    message: &quot;End time must be after the start time.&quot;,&#10;    path: [&quot;endTime&quot;],&#10;});&#10;&#10;&#10;// --- Final Event Schema ---&#10;&#10;export const createEventSchema = z.object({&#10;    title: z.string().min(3, { message: &quot;Title must be at least 3 characters.&quot; }),&#10;    description: z.string().optional(),&#10;    overview: z.string().optional(),&#10;    organizationId: z.string().uuid(),&#10;    categoryId: z.string().uuid({ message: &quot;Please select a category.&quot; }),&#10;    tiers: z.array(tierSchema).min(1, { message: &quot;You must create at least one tier.&quot; }),&#10;    sessions: z.array(sessionSchema).min(1, { message: &quot;You must schedule at least one session.&quot; }),&#10;});&#10;&#10;// --- Type Inference ---&#10;&#10;export type CreateEventFormData = z.infer&lt;typeof createEventSchema&gt;;&#10;&#10;// --- Step-by-Step Validation Fields ---&#10;&#10;export const stepValidationFields = {&#10;    1: ['title', 'categoryId', 'description', 'overview'] as const,&#10;    2: ['tiers'] as const,&#10;    3: ['sessions'] as const,&#10;    // Step 4 is for seating, which is part of the session object&#10;    // Step 5 is for cover photos and review (handled separately)&#10;} as const;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/providers/LimitProvider.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/providers/LimitProvider.ts" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return (&#10;        &lt;LimitContext.Provider value={value}&gt;&#10;            {children}&#10;        &lt;/LimitContext.Provider&gt;&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return React.createElement(&#10;        LimitContext.Provider,&#10;        { value },&#10;        children&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>