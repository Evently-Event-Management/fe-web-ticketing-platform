<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/providers/LimitProvider.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/providers/LimitProvider.ts" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return (&#10;        &lt;LimitContext.Provider value={value}&gt;&#10;            {children}&#10;        &lt;/LimitContext.Provider&gt;&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, {createContext, useContext, useState, useEffect, ReactNode, useMemo} from 'react';&#10;import {useAuth} from '@/providers/AuthProvider';&#10;import {getAppConfiguration} from '@/lib/actions/configActions';&#10;import {AppConfig, TierLimitDetails, TierName} from '@/types/config';&#10;&#10;// Define the shape of the context&#10;interface LimitContextType {&#10;    config: AppConfig | null;&#10;    isLoading: boolean;&#10;    error: string | null;&#10;    currentUserTier: TierName;&#10;    currentUserTierLimits: TierLimitDetails | null;&#10;    getLimitsForTier: (tier: TierName) =&gt; TierLimitDetails | null;&#10;}&#10;&#10;const LimitContext = createContext&lt;LimitContextType | undefined&gt;(undefined);&#10;&#10;export const LimitProvider = ({children}: { children: ReactNode }) =&gt; {&#10;    const {keycloak} = useAuth();&#10;    const [config, setConfig] = useState&lt;AppConfig | null&gt;(null);&#10;    const [isLoading, setIsLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;    // Fetch the entire configuration on initial application load&#10;    useEffect(() =&gt; {&#10;        const fetchConfig = async () =&gt; {&#10;            try {&#10;                const appConfig = await getAppConfiguration();&#10;                setConfig(appConfig);&#10;            } catch (err) {&#10;                setError('Failed to load application configuration. Some features may be unavailable.');&#10;                console.error(err);&#10;            } finally {&#10;                setIsLoading(false);&#10;            }&#10;        };&#10;        fetchConfig();&#10;    }, []);&#10;&#10;    // A memoized helper to get the current user's highest tier from their JWT&#10;    const currentUserTier = useMemo((): TierName =&gt; {&#10;        if (!keycloak?.tokenParsed?.user_groups || !Array.isArray(keycloak.tokenParsed.user_groups)) return 'FREE';&#10;&#10;        const userGroups: string[] = keycloak.tokenParsed.user_groups;&#10;        let highestTier: TierName = 'FREE';&#10;        let maxLevel = 0;&#10;&#10;        const tierLevels: Record&lt;TierName, number&gt; = {FREE: 0, PRO: 1, ENTERPRISE: 2};&#10;&#10;        userGroups.forEach(group =&gt; {&#10;            if (group.startsWith('/Tiers/')) {&#10;                const tierName = group.substring('/Tiers/'.length).toUpperCase() as TierName;&#10;                if (tierLevels[tierName] !== undefined &amp;&amp; tierLevels[tierName] &gt; maxLevel) {&#10;                    maxLevel = tierLevels[tierName];&#10;                    highestTier = tierName;&#10;                }&#10;            }&#10;        });&#10;        return highestTier;&#10;    }, [keycloak]);&#10;&#10;    // A memoized value for the current user's specific limits, derived from the full config&#10;    const currentUserTierLimits = useMemo(() =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[currentUserTier] || config.tierLimits.FREE;&#10;    }, [config, currentUserTier]);&#10;&#10;    // A function to get limits for any specified tier (useful for upgrade pages)&#10;    const getLimitsForTier = (tier: TierName): TierLimitDetails | null =&gt; {&#10;        if (!config) return null;&#10;        return config.tierLimits[tier] || null;&#10;    };&#10;&#10;    const value = {config, isLoading, error, currentUserTier, currentUserTierLimits, getLimitsForTier};&#10;&#10;    return React.createElement(&#10;        LimitContext.Provider,&#10;        { value },&#10;        children&#10;    );&#10;};&#10;&#10;// The custom hook to easily access the limits from any component&#10;export const useLimits = (): LimitContextType =&gt; {&#10;    const context = useContext(LimitContext);&#10;    if (context === undefined) {&#10;        throw new Error('useLimits must be used within a LimitProvider');&#10;    }&#10;    return context;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>